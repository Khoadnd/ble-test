<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MotoHUD Navigator</title>
    <meta name="description" content="Motorcycle HUD Navigation Brain â€” Mapbox + BLE">

    <!-- Mapbox GL JS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.9.4/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.9.4/mapbox-gl.js"></script>
    <!-- Mapbox Geocoder -->
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.3/mapbox-gl-geocoder.css"
        rel="stylesheet">
    <script
        src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.3/mapbox-gl-geocoder.min.js"></script>
    <!-- Turf.js -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #00c8ff;
            --accent-dim: rgba(0, 200, 255, 0.15);
            --bg: #0a0e1a;
            --card: #141828;
            --card-border: #1e2540;
            --text: #e8eaf0;
            --text-dim: #6b7394;
            --success: #00e878;
            --danger: #ff4466;
            --radius: 14px;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        /* â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* â”€â”€ Top Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 50px 16px 12px;
            background: linear-gradient(to bottom, rgba(10, 14, 26, 0.95) 60%, transparent);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ble-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger);
            flex-shrink: 0;
            transition: background 0.3s;
            box-shadow: 0 0 8px var(--danger);
        }

        .ble-indicator.connected {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .top-bar .status-text {
            font-size: 13px;
            color: var(--text-dim);
            flex: 1;
        }

        /* â”€â”€ Bottom Sheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card);
            border-top: 1px solid var(--card-border);
            border-radius: 20px 20px 0 0;
            padding: 16px 16px calc(12px + var(--safe-bottom));
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .sheet-handle {
            width: 36px;
            height: 4px;
            background: var(--card-border);
            border-radius: 2px;
            margin: 0 auto 14px;
        }

        /* â”€â”€ Nav Info (shown during navigation) â”€â”€ */
        .nav-info {
            display: none;
            text-align: center;
            margin-bottom: 14px;
        }

        .nav-info.active {
            display: block;
        }

        .nav-icon {
            font-size: 42px;
            margin-bottom: 4px;
        }

        .nav-street {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nav-distance {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent);
        }

        .nav-unit {
            font-size: 14px;
            color: var(--text-dim);
            margin-left: 4px;
        }

        /* â”€â”€ Destination input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .dest-section {
            margin-bottom: 12px;
        }

        .dest-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }

        .dest-input:focus {
            border-color: var(--accent);
        }

        .dest-input::placeholder {
            color: var(--text-dim);
        }

        /* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: var(--radius);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-bottom: 8px;
        }

        .btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            transform: none;
        }

        .btn-connect {
            background: linear-gradient(135deg, #0066ff, #0099ff);
            color: white;
        }

        .btn-navigate {
            background: linear-gradient(135deg, #00b856, #00e878);
            color: white;
        }

        .btn-stop {
            background: var(--danger);
            color: white;
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn-row .btn {
            flex: 1;
        }

        /* â”€â”€ Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .log-toggle {
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
            padding: 6px;
            cursor: pointer;
        }

        .log-panel {
            display: none;
            max-height: 150px;
            overflow-y: auto;
            background: var(--bg);
            border-radius: 10px;
            padding: 10px;
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .log-panel.open {
            display: block;
        }

        .log-entry {
            padding: 3px 0;
            color: var(--text-dim);
        }

        .log-entry.sent {
            color: #3498db;
        }

        .log-entry.recv {
            color: var(--success);
        }

        .log-entry.err {
            color: var(--danger);
        }

        /* â”€â”€ Token Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .token-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.97);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .token-overlay.hidden {
            display: none;
        }

        .token-card {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 400px;
            width: 100%;
        }

        .token-card h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }

        .token-card p {
            font-size: 13px;
            color: var(--text-dim);
            margin-bottom: 16px;
        }

        .token-card input {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            color: var(--text);
            font-size: 14px;
            font-family: 'SF Mono', monospace;
            outline: none;
            margin-bottom: 12px;
        }

        .token-card input:focus {
            border-color: var(--accent);
        }

        /* â”€â”€ Geocoder override â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .mapboxgl-ctrl-geocoder {
            width: 100% !important;
            max-width: none !important;
            background: var(--bg) !important;
            border: 1px solid var(--card-border) !important;
            border-radius: var(--radius) !important;
            color: var(--text) !important;
            box-shadow: none !important;
            font-size: 15px !important;
        }

        .mapboxgl-ctrl-geocoder input {
            color: var(--text) !important;
        }

        .mapboxgl-ctrl-geocoder .suggestions {
            background: var(--card) !important;
            border: 1px solid var(--card-border) !important;
            border-radius: 10px !important;
        }

        .mapboxgl-ctrl-geocoder .suggestions .active>a,
        .mapboxgl-ctrl-geocoder .suggestions>li>a:hover {
            background: var(--accent-dim) !important;
            color: var(--text) !important;
        }

        .mapboxgl-ctrl-geocoder .suggestions>li>a {
            color: var(--text) !important;
        }
    </style>
</head>

<body>

    <!-- â•â•â•â• TOKEN OVERLAY â•â•â•â• -->
    <div class="token-overlay" id="tokenOverlay">
        <div class="token-card">
            <h2>ğŸ—ºï¸ Mapbox Token</h2>
            <p>Paste your Mapbox access token below. It will be saved in your browser for next time.</p>
            <input type="text" id="tokenInput" placeholder="pk.eyJ1Ijo..." autocomplete="off" spellcheck="false">
            <button class="btn btn-connect" id="tokenBtn">Start Map</button>
        </div>
    </div>

    <!-- â•â•â•â• MAP â•â•â•â• -->
    <div id="map"></div>

    <!-- â•â•â•â• TOP BAR â•â•â•â• -->
    <div class="top-bar">
        <div class="ble-indicator" id="bleIndicator"></div>
        <span class="status-text" id="statusText">Tap Connect to pair with MotoHUD</span>
    </div>

    <!-- â•â•â•â• BOTTOM SHEET â•â•â•â• -->
    <div class="bottom-sheet">
        <div class="sheet-handle"></div>

        <!-- Nav info (visible during navigation) -->
        <div class="nav-info" id="navInfo">
            <div class="nav-icon" id="navIcon">â†‘</div>
            <div class="nav-street" id="navStreet">â€”</div>
            <div>
                <span class="nav-distance" id="navDist">--</span>
                <span class="nav-unit" id="navUnit"></span>
            </div>
        </div>

        <!-- Destination search -->
        <div class="dest-section" id="destSection">
            <div id="geocoder"></div>
        </div>

        <!-- Buttons -->
        <div id="connectRow">
            <button class="btn btn-connect" id="connectBtn">ğŸ”µ Connect to MotoHUD</button>
        </div>
        <div id="navRow" style="display:none;">
            <div class="btn-row">
                <button class="btn btn-navigate" id="navBtn" disabled>Navigate</button>
                <button class="btn btn-stop" id="stopBtn" style="display:none;">Stop</button>
            </div>
        </div>

        <!-- Log -->
        <div class="log-toggle" id="logToggle">â–¼ Show Log</div>
        <div class="log-panel" id="logPanel"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let MAPBOX_TOKEN = localStorage.getItem('mapbox_token') || '';

        // BLE UUIDs â€” must match ESP32 firmware
        const BLE_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
        const BLE_NAV_CHAR_UUID = '12345678-1234-1234-1234-123456789abd';
        const BLE_DEVICE_NAME = 'MotoHUD';

        // Nav update rate (ms)
        const NAV_UPDATE_INTERVAL = 50;

        // Maneuver icon map â†’ icon_id for ESP32
        const MANEUVER_MAP = {
            'straight': 0, 'turn right': 2, 'turn left': 1,
            'sharp right': 2, 'sharp left': 1,
            'slight right': 2, 'slight left': 1,
            'uturn': 3, 'arrive': 4, 'depart': 0,
            'merge right': 2, 'merge left': 1,
            'roundabout': 2, 'rotary': 2,
            'fork right': 2, 'fork left': 1,
            'ramp right': 2, 'ramp left': 1,
            'continue': 0, 'end of road right': 2, 'end of road left': 1,
        };

        const ICON_ARROWS = ['â†‘', 'â†', 'â†’', 'â†©', 'âœ“'];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let bleDevice = null, bleChar = null, bleConnected = false;
        let map, userMarker, gpsWatchId = null;
        let currentPos = null;
        let routeGeometry = null, routeSteps = null;
        let navigating = false, navTimer = null;
        let destCoords = null;
        let lastSendTime = 0;
        let isWriting = false;

        // Background audio keep-alive
        let silentAudio = new Audio();
        silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAASAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAATMOpAAAAAABhAAaAAAAABzsDPwMHAwADAwMAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA';
        silentAudio.loop = true;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  DOM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const $ = id => document.getElementById(id);
        const bleIndicator = $('bleIndicator');
        const statusText = $('statusText');
        const connectBtn = $('connectBtn');
        const navBtn = $('navBtn');
        const stopBtn = $('stopBtn');
        const navInfo = $('navInfo');
        const navIcon = $('navIcon');
        const navStreet = $('navStreet');
        const navDist = $('navDist');
        const navUnit = $('navUnit');
        const logPanel = $('logPanel');
        const logToggle = $('logToggle');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  LOG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function log(msg, type = '') {
            const ts = new Date().toLocaleTimeString('en-US', { hour12: false });
            const el = document.createElement('div');
            el.className = 'log-entry ' + type;
            el.textContent = `[${ts}] ${msg}`;
            logPanel.appendChild(el);
            logPanel.scrollTop = logPanel.scrollHeight;
            // keep max 100 entries
            while (logPanel.children.length > 100) logPanel.removeChild(logPanel.firstChild);
        }

        logToggle.onclick = () => {
            logPanel.classList.toggle('open');
            logToggle.textContent = logPanel.classList.contains('open') ? 'â–² Hide Log' : 'â–¼ Show Log';
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE  â€” Web Bluetooth
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function bleConnect() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth not available.\nUse Bluefy on iOS or Chrome on Android with HTTPS.');
                return;
            }

            try {
                // Start background audio (needs user gesture)
                silentAudio.play().then(() => {
                    log('ğŸµ Background audio started');
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: 'MotoHUD Active', artist: 'Navigation', album: 'Background Mode',
                        });
                        navigator.mediaSession.setActionHandler('play', () => silentAudio.play());
                        navigator.mediaSession.setActionHandler('pause', () => silentAudio.play());
                    }
                }).catch(e => log('Audio: ' + e.message, 'err'));

                silentAudio.onpause = () => {
                    silentAudio.play().catch(() => { });
                };

                statusText.textContent = 'Scanning for MotoHUDâ€¦';
                log('Requesting BLE deviceâ€¦');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: BLE_DEVICE_NAME }],
                    optionalServices: [BLE_SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onBleDisconnect);

                // Bluefy helpers
                if (navigator.bluetooth.setScreenDimEnabled) {
                    try { navigator.bluetooth.setScreenDimEnabled(false); } catch (_) { }
                }

                statusText.textContent = 'Connectingâ€¦';
                const server = await bleDevice.gatt.connect();
                const service = await server.getPrimaryService(BLE_SERVICE_UUID);
                bleChar = await service.getCharacteristic(BLE_NAV_CHAR_UUID);

                bleConnected = true;
                bleIndicator.classList.add('connected');
                statusText.textContent = 'Connected to MotoHUD';
                connectBtn.textContent = 'ğŸ”µ Connected';
                connectBtn.disabled = true;
                $('navRow').style.display = 'block';

                log('âœ… BLE connected');

            } catch (e) {
                log('BLE error: ' + (e.message || e), 'err');
                statusText.textContent = 'Connection failed â€” tap to retry';
                silentAudio.pause();
            }
        }

        function onBleDisconnect() {
            bleConnected = false;
            bleChar = null;
            bleIndicator.classList.remove('connected');
            statusText.textContent = 'Disconnected â€” tap Connect';
            connectBtn.textContent = 'ğŸ”µ Connect to MotoHUD';
            connectBtn.disabled = false;
            log('âŒ BLE disconnected');
            if (navigating) stopNavigation();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE â€” NavPacket sender
        //  Struct: { uint8 icon_id, uint32 dist_meters (LE), char[32] street }
        //  Total: 37 bytes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Strip Vietnamese diacritics â†’ ASCII (ESP32 fonts are Latin-only)
        function stripDiacritics(str) {
            // Vietnamese-specific replacements for Ä‘/Ä (not handled by NFD)
            str = str.replace(/Ä‘/g, 'd').replace(/Ä/g, 'D');
            // NFD decompose then strip combining marks
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        // Truncate a string so its UTF-8 encoding fits within maxBytes
        function truncateToBytes(str, maxBytes) {
            const encoder = new TextEncoder();
            let encoded = encoder.encode(str);
            if (encoded.length <= maxBytes) return encoded;
            // Binary search for longest substring that fits
            let lo = 0, hi = str.length;
            while (lo < hi) {
                const mid = (lo + hi + 1) >> 1;
                if (encoder.encode(str.substring(0, mid)).length <= maxBytes) {
                    lo = mid;
                } else {
                    hi = mid - 1;
                }
            }
            return encoder.encode(str.substring(0, lo));
        }

        const PACKET_SIZE = 37;     // 1 + 4 + 32
        const STREET_MAX_BYTES = 32;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE â€” Multiplexed Sender
        //  Opcode 0x01: Data (Icon, Dist, ETA)
        //  Opcode 0x02: Next Street
        //  Opcode 0x03: Current Street
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const PKT_NAV_DATA = 0x01;
        const PKT_NEXT_STR = 0x02;
        const PKT_CURR_STR = 0x03;

        let lastNextStr = '';
        let lastCurrStr = '';

        async function bleWrite(buf) {
            if (!bleChar || !bleConnected || isWriting) return;
            isWriting = true;
            try {
                await bleChar.writeValueWithoutResponse(buf);
            } catch (e) {
                // log('Write error: ' + e.message, 'err');
            } finally {
                isWriting = false;
            }
        }

        async function sendNavData(iconId, distMeters, etaSeconds) {
            const now = Date.now();
            if (now - lastSendTime < NAV_UPDATE_INTERVAL) return;
            lastSendTime = now;

            const buf = new ArrayBuffer(10);
            const dv = new DataView(buf);
            dv.setUint8(0, PKT_NAV_DATA);
            dv.setUint8(1, iconId);
            dv.setUint32(2, Math.round(distMeters), true);
            dv.setUint32(6, Math.round(etaSeconds), true);
            await bleWrite(buf);
        }

        async function sendString(type, str) {
            str = stripDiacritics(str || '').trim();

            // Deduplicate logic
            if (type === PKT_NEXT_STR) {
                if (str === lastNextStr) return;
                lastNextStr = str;
            } else if (type === PKT_CURR_STR) {
                if (str === lastCurrStr) return;
                lastCurrStr = str;
            }

            const encoded = truncateToBytes(str, 32);
            const buf = new ArrayBuffer(1 + encoded.length);
            const u8 = new Uint8Array(buf);
            u8[0] = type;
            u8.set(encoded, 1);

            // Force write immediately (bypass interval check)
            try { await bleChar.writeValueWithoutResponse(buf); } catch (e) { }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  MAP â€” Mapbox GL JS (deferred until token is set)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initMap() {
            mapboxgl.accessToken = MAPBOX_TOKEN;

            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/dark-v11',
                center: [100.5018, 13.7563],
                zoom: 13,
                attributionControl: false
            });

            const geocoder = new MapboxGeocoder({
                accessToken: MAPBOX_TOKEN,
                mapboxgl: mapboxgl,
                placeholder: 'Where to?',
                marker: false,
                flyTo: { speed: 2 }
            });
            $('geocoder').appendChild(geocoder.onAdd(map));

            geocoder.on('result', (e) => {
                destCoords = e.result.center;
                navBtn.disabled = false;
                log('ğŸ“ Destination: ' + e.result.place_name);

                // Destination marker
                if (window._destMarker) window._destMarker.remove();
                window._destMarker = new mapboxgl.Marker({ color: '#ff4466' })
                    .setLngLat(destCoords)
                    .addTo(map);

                // Auto-preview route
                if (currentPos) {
                    fetchAndDrawRoute(currentPos, destCoords, true);
                }

                // Fit map to show both origin & destination
                if (currentPos) {
                    map.fitBounds([currentPos, destCoords], {
                        padding: { top: 100, bottom: 280, left: 40, right: 40 },
                        maxZoom: 15
                    });
                }
            });

            // Geolocate control â€” auto-trigger on load
            const geoCtrl = new mapboxgl.GeolocateControl({
                positionOptions: { enableHighAccuracy: true },
                trackUserLocation: true,
                showUserHeading: true
            });
            map.addControl(geoCtrl, 'top-right');

            map.on('load', () => {
                log('ğŸ—ºï¸ Map loaded');
                // Auto-trigger location (shows blue dot immediately)
                geoCtrl.trigger();
                startGpsWatch();
            });

            log('Map initialized with token');
        }

        // Fetch route and draw it. If `previewOnly`, just draw without starting nav.
        async function fetchAndDrawRoute(origin, dest, previewOnly = false) {
            try {
                const url = `https://api.mapbox.com/directions/v5/mapbox/driving/` +
                    `${origin[0]},${origin[1]};${dest[0]},${dest[1]}` +
                    `?geometries=geojson&overview=full&steps=true&access_token=${MAPBOX_TOKEN}`;

                const res = await fetch(url);
                const data = await res.json();

                if (!data.routes || !data.routes.length) {
                    log('No route found', 'err');
                    return null;
                }

                const route = data.routes[0];
                drawRoute(route.geometry);

                if (previewOnly) {
                    const mins = Math.round(route.duration / 60);
                    const km = (route.distance / 1000).toFixed(1);
                    navBtn.textContent = `Navigate (${km} km Â· ${mins} min)`;
                    log(`Route preview: ${km} km, ~${mins} min`);
                }

                return route;
            } catch (e) {
                log('Route error: ' + e.message, 'err');
                return null;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  GPS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function startGpsWatch() {
            if (!navigator.geolocation) { log('No GPS', 'err'); return; }
            gpsWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    if (navigating) onGpsUpdate();
                },
                (err) => log('GPS error: ' + err.message, 'err'),
                { enableHighAccuracy: true, maximumAge: 2000 }
            );
            log('ğŸ“¡ GPS watch started');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  NAVIGATION ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function startNavigation() {
            if (!currentPos) {
                // Actively request GPS (triggers permission prompt if needed)
                statusText.textContent = 'Requesting GPSâ€¦';
                log('ğŸ“¡ Requesting GPS permissionâ€¦');
                try {
                    const pos = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true, timeout: 10000
                        });
                    });
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    startGpsWatch(); // restart watch now that we have permission
                } catch (e) {
                    alert('Cannot get GPS location. Please allow location access and try again.');
                    statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                    log('GPS denied: ' + e.message, 'err');
                    return;
                }
            }
            if (!destCoords) {
                alert('Please select a destination first');
                return;
            }

            log('ğŸ§­ Starting navigationâ€¦');
            statusText.textContent = 'Calculating routeâ€¦';

            const route = await fetchAndDrawRoute(currentPos, destCoords, false);
            if (!route) {
                alert('No route found');
                statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                return;
            }

            routeGeometry = route.geometry;
            routeSteps = [];

            // Flatten steps from all legs
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    routeSteps.push({
                        maneuver: step.maneuver,
                        name: step.name || '',
                        distance: step.distance,
                        duration: step.duration || 0,
                        location: step.maneuver.location
                    });
                }
            }

            log(`Route: ${routeSteps.length} steps, ${(route.distance / 1000).toFixed(1)} km`);

            // Start nav mode
            navigating = true;
            navInfo.classList.add('active');
            navBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            $('destSection').style.display = 'none';
            statusText.textContent = 'Navigatingâ€¦';

            // Initial update
            onGpsUpdate();
        }

        function stopNavigation() {
            navigating = false;
            navInfo.classList.remove('active');
            navBtn.style.display = 'block';
            navBtn.textContent = 'Navigate';
            stopBtn.style.display = 'none';
            $('destSection').style.display = 'block';
            statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';

            // Remove route layer
            if (map.getLayer('route')) map.removeLayer('route');
            if (map.getSource('route')) map.removeSource('route');

            log('â¹ Navigation stopped');
        }

        function drawRoute(geometry) {
            if (map.getLayer('route')) map.removeLayer('route');
            if (map.getSource('route')) map.removeSource('route');

            map.addSource('route', {
                type: 'geojson',
                data: { type: 'Feature', geometry: geometry }
            });

            map.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': '#00c8ff',
                    'line-width': 5,
                    'line-opacity': 0.8
                }
            }, 'road-label');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  SNAPPING ENGINE (Turf.js)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function onGpsUpdate() {
            if (!currentPos || !routeGeometry || !routeSteps || routeSteps.length === 0) return;

            const routeLine = turf.lineString(routeGeometry.coordinates);
            const pt = turf.point(currentPos);

            // Snap to route
            const snapped = turf.nearestPointOnLine(routeLine, pt, { units: 'meters' });
            const snappedDist = snapped.properties.location; // distance along route in meters (approx from index)

            // Find NEXT step: the one whose maneuver point we haven't passed yet
            let nextStepIdx = 0;
            let accumDist = 0;

            for (let i = 0; i < routeSteps.length; i++) {
                const stepPt = turf.point(routeSteps[i].location);
                const stepDist = turf.distance(pt, stepPt, { units: 'meters' });

                // If we're within 30m of a step, we've reached it â€” look at the next one
                if (stepDist < 30 && i < routeSteps.length - 1) {
                    nextStepIdx = i + 1;
                    continue;
                }

                // Find next step that's ahead of us
                if (i > nextStepIdx) {
                    // Check if this step's maneuver point is ahead on the route
                    const maneuverPt = turf.point(routeSteps[i].location);
                    const distToManeuver = turf.distance(pt, maneuverPt, { units: 'meters' });

                    if (distToManeuver > 20) {
                        nextStepIdx = i;
                        break;
                    }
                }
            }

            const nextStep = routeSteps[nextStepIdx];
            if (!nextStep) return;

            // Distance from current position to next maneuver
            const maneuverPt = turf.point(nextStep.location);
            const distToTurn = turf.distance(pt, maneuverPt, { units: 'meters' });

            // Map maneuver type â†’ icon_id
            const modifier = nextStep.maneuver.modifier || '';
            const mType = nextStep.maneuver.type || '';
            let iconId = 0;

            // Try combined type + modifier first
            const combined = `${mType} ${modifier}`.trim().toLowerCase();
            if (MANEUVER_MAP[combined] !== undefined) {
                iconId = MANEUVER_MAP[combined];
            } else if (MANEUVER_MAP[mType] !== undefined) {
                iconId = MANEUVER_MAP[mType];
            } else if (modifier.includes('right')) {
                iconId = 2;
            } else if (modifier.includes('left')) {
                iconId = 1;
            } else if (modifier.includes('uturn')) {
                iconId = 3;
            }

            // Check for arrival
            if (mType === 'arrive' || nextStepIdx === routeSteps.length - 1 && distToTurn < 50) {
                iconId = 4;
            }

            const streetName = nextStep.name || nextStep.maneuver.instruction || '';

            // Identify Current Street (Road we are currently on)
            let currStreetName = 'Start';
            if (nextStepIdx > 0 && routeSteps[nextStepIdx - 1]) {
                currStreetName = routeSteps[nextStepIdx - 1].name || 'Road';
            }

            // Calculate ETA (Remaining duration)
            let etaSeconds = 0;
            // Time for current step partial
            if (nextStep.distance > 0) {
                const frac = distToTurn / nextStep.distance; // Fraction remaining
                etaSeconds += (nextStep.duration || 0) * frac;
            }
            // Sum remaining steps
            for (let k = nextStepIdx + 1; k < routeSteps.length; k++) {
                etaSeconds += routeSteps[k].duration || 0;
            }

            // Update web UI
            navIcon.textContent = ICON_ARROWS[iconId] || 'â†‘';
            navStreet.textContent = streetName || 'â€”';
            if (distToTurn >= 1000) {
                navDist.textContent = (distToTurn / 1000).toFixed(1);
                navUnit.textContent = 'km';
            } else {
                navDist.textContent = Math.round(distToTurn);
                navUnit.textContent = 'm';
            }

            // Send to ESP32 (Multiplexed)
            await sendNavData(iconId, distToTurn, etaSeconds);
            await sendString(PKT_NEXT_STR, streetName);
            await sendString(PKT_CURR_STR, currStreetName);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  TOKEN FLOW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const tokenOverlay = $('tokenOverlay');
        const tokenInput = $('tokenInput');
        const tokenBtn = $('tokenBtn');

        function applyToken() {
            const t = tokenInput.value.trim();
            if (!t || !t.startsWith('pk.')) {
                alert('Please enter a valid Mapbox token (starts with pk.)');
                return;
            }
            MAPBOX_TOKEN = t;
            localStorage.setItem('mapbox_token', t);
            tokenOverlay.classList.add('hidden');
            initMap();
        }

        tokenBtn.addEventListener('click', applyToken);
        tokenInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyToken(); });

        // Auto-init if token already saved
        if (MAPBOX_TOKEN && MAPBOX_TOKEN.startsWith('pk.')) {
            tokenOverlay.classList.add('hidden');
            initMap();
        } else {
            tokenInput.focus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  EVENT LISTENERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        connectBtn.addEventListener('click', bleConnect);
        navBtn.addEventListener('click', startNavigation);
        stopBtn.addEventListener('click', stopNavigation);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('ğŸ“± App backgrounded');
            } else {
                log('ğŸ“± App foregrounded');
            }
        });

        window.addEventListener('load', () => {
            if (!navigator.bluetooth) {
                log('âš ï¸ Web Bluetooth not available â€” use Bluefy or Chrome HTTPS', 'err');
            } else {
                log('âœ… Web Bluetooth ready');
            }
        });
    </script>
</body>

</html>