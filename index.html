<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MotoHUD Navigator</title>
    <meta name="description" content="Motorcycle HUD Navigation Brain â€” Google Maps + BLE">

    <!-- Google Maps JS API is loaded dynamically after API key input -->
    <!-- Turf.js -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #00c8ff;
            --accent-dim: rgba(0, 200, 255, 0.15);
            --bg: #0a0e1a;
            --card: #141828;
            --card-border: #1e2540;
            --text: #e8eaf0;
            --text-dim: #6b7394;
            --success: #00e878;
            --danger: #ff4466;
            --radius: 14px;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        /* â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* â”€â”€ Top Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 50px 16px 12px;
            background: linear-gradient(to bottom, rgba(10, 14, 26, 0.95) 60%, transparent);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ble-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger);
            flex-shrink: 0;
            transition: background 0.3s;
            box-shadow: 0 0 8px var(--danger);
        }

        .ble-indicator.connected {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .top-bar .status-text {
            font-size: 13px;
            color: var(--text-dim);
            flex: 1;
        }

        /* â”€â”€ Bottom Sheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card);
            border-top: 1px solid var(--card-border);
            border-radius: 20px 20px 0 0;
            padding: 16px 16px calc(12px + var(--safe-bottom));
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .sheet-handle {
            width: 36px;
            height: 4px;
            background: var(--card-border);
            border-radius: 2px;
            margin: 0 auto 14px;
        }

        /* â”€â”€ Nav Info (shown during navigation) â”€â”€ */
        .nav-info {
            display: none;
            text-align: center;
            margin-bottom: 14px;
        }

        .nav-info.active {
            display: block;
        }

        .nav-icon {
            font-size: 42px;
            margin-bottom: 4px;
        }

        .nav-street {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nav-distance {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent);
        }

        .nav-unit {
            font-size: 14px;
            color: var(--text-dim);
            margin-left: 4px;
        }

        /* â”€â”€ Destination input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .dest-section {
            margin-bottom: 12px;
        }

        .dest-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }

        .dest-input:focus {
            border-color: var(--accent);
        }

        .dest-input::placeholder {
            color: var(--text-dim);
        }

        /* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: var(--radius);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-bottom: 8px;
        }

        .btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            transform: none;
        }

        .btn-connect {
            background: linear-gradient(135deg, #0066ff, #0099ff);
            color: white;
        }

        .btn-navigate {
            background: linear-gradient(135deg, #00b856, #00e878);
            color: white;
        }

        .btn-stop {
            background: var(--danger);
            color: white;
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn-row .btn {
            flex: 1;
        }

        /* â”€â”€ Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .log-toggle {
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
            padding: 6px;
            cursor: pointer;
        }

        .log-panel {
            display: none;
            max-height: 150px;
            overflow-y: auto;
            background: var(--bg);
            border-radius: 10px;
            padding: 10px;
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .log-panel.open {
            display: block;
        }

        .log-entry {
            padding: 3px 0;
            color: var(--text-dim);
        }

        .log-entry.sent {
            color: #3498db;
        }

        .log-entry.recv {
            color: var(--success);
        }

        .log-entry.err {
            color: var(--danger);
        }

        /* â”€â”€ Token Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .token-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.97);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .token-overlay.hidden {
            display: none;
        }

        .token-card {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 400px;
            width: 100%;
        }

        .token-card h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }

        .token-card p {
            font-size: 13px;
            color: var(--text-dim);
            margin-bottom: 16px;
        }

        .token-card input {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            color: var(--text);
            font-size: 14px;
            font-family: 'SF Mono', monospace;
            outline: none;
            margin-bottom: 12px;
        }

        .token-card input:focus {
            border-color: var(--accent);
        }

    </style>
</head>

<body>

    <!-- â•â•â•â• TOKEN OVERLAY â•â•â•â• -->
    <div class="token-overlay" id="keyOverlay">
        <div class="token-card">
            <h2>ğŸ—ºï¸ Google Maps API Key</h2>
            <p>Paste your Google Maps JavaScript API key. It will be saved in your browser for next time.</p>
            <input type="text" id="keyInput" placeholder="AIza..." autocomplete="off" spellcheck="false">
            <button class="btn btn-connect" id="keyBtn">Start Map</button>
        </div>
    </div>

    <!-- â•â•â•â• MAP â•â•â•â• -->
    <div id="map"></div>

    <!-- â•â•â•â• TOP BAR â•â•â•â• -->
    <div class="top-bar">
        <div class="ble-indicator" id="bleIndicator"></div>
        <span class="status-text" id="statusText">Tap Connect to pair with MotoHUD</span>
    </div>

    <!-- â•â•â•â• BOTTOM SHEET â•â•â•â• -->
    <div class="bottom-sheet">
        <div class="sheet-handle"></div>

        <!-- Nav info (visible during navigation) -->
        <div class="nav-info" id="navInfo">
            <div class="nav-icon" id="navIcon">â†‘</div>
            <div class="nav-street" id="navStreet">â€”</div>
            <div>
                <span class="nav-distance" id="navDist">--</span>
                <span class="nav-unit" id="navUnit"></span>
            </div>
        </div>

        <!-- Destination search -->
        <div class="dest-section" id="destSection">
            <input class="dest-input" id="destInput" type="text" placeholder="Where to?" autocomplete="off">
        </div>

        <!-- Buttons -->
        <div id="connectRow">
            <button class="btn btn-connect" id="connectBtn">ğŸ”µ Connect to MotoHUD</button>
        </div>
        <div id="navRow" style="display:none;">
            <div class="btn-row">
                <button class="btn btn-navigate" id="navBtn" disabled>Navigate</button>
                <button class="btn btn-stop" id="stopBtn" style="display:none;">Stop</button>
            </div>
        </div>

        <!-- Log -->
        <div class="log-toggle" id="logToggle">â–¼ Show Log</div>
        <div class="log-panel" id="logPanel"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let GOOGLE_MAPS_KEY = localStorage.getItem('gmaps_key') || '';

        // BLE UUIDs â€” must match ESP32 firmware
        const BLE_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
        const BLE_NAV_CHAR_UUID = '12345678-1234-1234-1234-123456789abd';
        const BLE_DEVICE_NAME = 'MotoHUD';

        // Nav update rate (ms)
        const NAV_UPDATE_INTERVAL = 250;

        // Maneuver icon map â†’ icon_id for ESP32
        const MANEUVER_MAP = {
            'straight': 0,
            'turn-left': 1,
            'turn-right': 2,
            'turn-slight-left': 1,
            'turn-slight-right': 2,
            'turn-sharp-left': 1,
            'turn-sharp-right': 2,
            'uturn-left': 3,
            'uturn-right': 3,
            'ramp-left': 1,
            'ramp-right': 2,
            'merge': 0,
            'fork-left': 1,
            'fork-right': 2,
            'keep-left': 1,
            'keep-right': 2,
            'roundabout-left': 2,
            'roundabout-right': 2,
            'ferry': 0,
            'ferry-train': 0,
        };

        const ICON_ARROWS = ['â†‘', 'â†', 'â†’', 'â†©', 'âœ“'];
        const PREVIEW_MAX_POINTS = 6;
        const PREVIEW_LOOKAHEAD = 200; // meters
        const PREVIEW_RANGE = 50; // coordinate range (-50..50)

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let bleDevice = null, bleChar = null, bleConnected = false;
        let map, userMarker, accuracyCircle, gpsWatchId = null;
        let directionsService = null;
        let routePolyline = null;
        let destMarker = null;
        let hasCentered = false;
        let currentPos = null;
        let routeGeometry = null, routeSteps = null;
        let navigating = false, navTimer = null;
        let destCoords = null;
        let lastSendTime = 0;
        let isWriting = false;

        // Background audio keep-alive
        let silentAudio = new Audio();
        silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAASAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAATMOpAAAAAABhAAaAAAAABzsDPwMHAwADAwMAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA';
        silentAudio.loop = true;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  DOM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const $ = id => document.getElementById(id);
        const bleIndicator = $('bleIndicator');
        const statusText = $('statusText');
        const connectBtn = $('connectBtn');
        const navBtn = $('navBtn');
        const stopBtn = $('stopBtn');
        const navInfo = $('navInfo');
        const navIcon = $('navIcon');
        const navStreet = $('navStreet');
        const navDist = $('navDist');
        const navUnit = $('navUnit');
        const logPanel = $('logPanel');
        const logToggle = $('logToggle');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  LOG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function log(msg, type = '') {
            const ts = new Date().toLocaleTimeString('en-US', { hour12: false });
            const el = document.createElement('div');
            el.className = 'log-entry ' + type;
            el.textContent = `[${ts}] ${msg}`;
            logPanel.appendChild(el);
            logPanel.scrollTop = logPanel.scrollHeight;
            // keep max 100 entries
            while (logPanel.children.length > 100) logPanel.removeChild(logPanel.firstChild);
        }

        logToggle.onclick = () => {
            logPanel.classList.toggle('open');
            logToggle.textContent = logPanel.classList.contains('open') ? 'â–² Hide Log' : 'â–¼ Show Log';
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE  â€” Web Bluetooth
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function bleConnect() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth not available.\nUse Bluefy on iOS or Chrome on Android with HTTPS.');
                return;
            }

            try {
                // Start background audio (needs user gesture)
                silentAudio.play().then(() => {
                    log('ğŸµ Background audio started');
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: 'MotoHUD Active', artist: 'Navigation', album: 'Background Mode',
                        });
                        navigator.mediaSession.setActionHandler('play', () => silentAudio.play());
                        navigator.mediaSession.setActionHandler('pause', () => silentAudio.play());
                    }
                }).catch(e => log('Audio: ' + e.message, 'err'));

                silentAudio.onpause = () => {
                    silentAudio.play().catch(() => { });
                };

                statusText.textContent = 'Scanning for MotoHUDâ€¦';
                log('Requesting BLE deviceâ€¦');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: BLE_DEVICE_NAME }],
                    optionalServices: [BLE_SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onBleDisconnect);

                // Bluefy helpers
                if (navigator.bluetooth.setScreenDimEnabled) {
                    try { navigator.bluetooth.setScreenDimEnabled(false); } catch (_) { }
                }

                statusText.textContent = 'Connectingâ€¦';
                const server = await bleDevice.gatt.connect();
                const service = await server.getPrimaryService(BLE_SERVICE_UUID);
                bleChar = await service.getCharacteristic(BLE_NAV_CHAR_UUID);

                bleConnected = true;
                bleIndicator.classList.add('connected');
                statusText.textContent = 'Connected to MotoHUD';
                connectBtn.textContent = 'ğŸ”µ Connected';
                connectBtn.disabled = true;
                $('navRow').style.display = 'block';

                log('âœ… BLE connected');

            } catch (e) {
                log('BLE error: ' + (e.message || e), 'err');
                statusText.textContent = 'Connection failed â€” tap to retry';
                silentAudio.pause();
            }
        }

        function onBleDisconnect() {
            bleConnected = false;
            bleChar = null;
            bleIndicator.classList.remove('connected');
            statusText.textContent = 'Disconnected â€” tap Connect';
            connectBtn.textContent = 'ğŸ”µ Connect to MotoHUD';
            connectBtn.disabled = false;
            log('âŒ BLE disconnected');
            if (navigating) stopNavigation();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE â€” NavPacket sender
        //  Struct: {
        //    uint8  icon_id,
        //    uint32 dist_meters (LE),
        //    char   street[32],
        //    uint8  preview_count,
        //    int8   preview_xy[12] (6 points: x,y)
        //  }
        //  Total: 50 bytes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Strip Vietnamese diacritics â†’ ASCII (ESP32 fonts are Latin-only)
        function stripDiacritics(str) {
            // Vietnamese-specific replacements for Ä‘/Ä (not handled by NFD)
            str = str.replace(/Ä‘/g, 'd').replace(/Ä/g, 'D');
            // NFD decompose then strip combining marks
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        // Truncate a string so its UTF-8 encoding fits within maxBytes
        function truncateToBytes(str, maxBytes) {
            const encoder = new TextEncoder();
            let encoded = encoder.encode(str);
            if (encoded.length <= maxBytes) return encoded;
            // Binary search for longest substring that fits
            let lo = 0, hi = str.length;
            while (lo < hi) {
                const mid = (lo + hi + 1) >> 1;
                if (encoder.encode(str.substring(0, mid)).length <= maxBytes) {
                    lo = mid;
                } else {
                    hi = mid - 1;
                }
            }
            return encoder.encode(str.substring(0, lo));
        }

        function stripHtml(html) {
            return (html || '').replace(/<[^>]+>/g, '').trim();
        }

        const PREVIEW_BYTES = PREVIEW_MAX_POINTS * 2;
        const STREET_MAX_BYTES = 32;
        const PREVIEW_COUNT_OFFSET = 1 + 4 + STREET_MAX_BYTES;
        const PREVIEW_DATA_OFFSET = PREVIEW_COUNT_OFFSET + 1;
        const PACKET_SIZE = PREVIEW_DATA_OFFSET + PREVIEW_BYTES;

        async function sendNavPacket(iconId, distMeters, street, preview) {
            if (!bleChar || !bleConnected || isWriting) return;

            const now = Date.now();
            if (now - lastSendTime < NAV_UPDATE_INTERVAL) return;
            lastSendTime = now;

            isWriting = true;
            try {
                const buf = new ArrayBuffer(PACKET_SIZE);
                const dv = new DataView(buf);
                dv.setUint8(0, iconId);
                dv.setUint32(1, Math.round(distMeters), true); // little-endian

                // Strip diacritics for ESP32 display, truncate to fit 32 bytes
                const ascii = stripDiacritics(street || '');
                const streetBytes = truncateToBytes(ascii, STREET_MAX_BYTES);
                const u8 = new Uint8Array(buf);
                u8.set(streetBytes, 5);   // rest is zero-padded by ArrayBuffer

                const previewCount = Math.min(PREVIEW_MAX_POINTS, preview?.count || 0);
                dv.setUint8(PREVIEW_COUNT_OFFSET, previewCount);
                const previewOffset = PREVIEW_DATA_OFFSET;
                for (let i = 0; i < PREVIEW_MAX_POINTS; i++) {
                    const idx = i * 2;
                    const px = preview?.points?.[i]?.x ?? 0;
                    const py = preview?.points?.[i]?.y ?? 0;
                    dv.setInt8(previewOffset + idx, px);
                    dv.setInt8(previewOffset + idx + 1, py);
                }

                await bleChar.writeValueWithoutResponse(buf);
            } catch (e) {
                log('Send error: ' + e.message, 'err');
            } finally {
                isWriting = false;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  MAP â€” Google Maps JS API (loaded after API key)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function loadGoogleMaps(key) {
            if (!key) return;
            if (window.google && window.google.maps) {
                initMap();
                return;
            }
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}&libraries=places&callback=initMap`;
            script.async = true;
            script.defer = true;
            script.onerror = () => {
                log('Google Maps failed to load. Check API key + network.', 'err');
                keyOverlay.classList.remove('hidden');
            };
            document.head.appendChild(script);
        }

        window.initMap = initMap;

        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 10.7769, lng: 106.7009 },
                zoom: 13,
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: false,
                gestureHandling: 'greedy',
                styles: [
                    { elementType: 'geometry', stylers: [{ color: '#0b0f1c' }] },
                    { elementType: 'labels.text.stroke', stylers: [{ color: '#0b0f1c' }] },
                    { elementType: 'labels.text.fill', stylers: [{ color: '#8c94b8' }] },
                    { featureType: 'poi', stylers: [{ visibility: 'off' }] },
                    { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#1b2138' }] },
                    { featureType: 'road', elementType: 'geometry.stroke', stylers: [{ color: '#2a3356' }] },
                    { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#05080f' }] },
                ]
            });

            directionsService = new google.maps.DirectionsService();
            setupAutocomplete();
            startGpsWatch();
            log('ğŸ—ºï¸ Map initialized');
        }

        function setupAutocomplete() {
            const input = $('destInput');
            const autocomplete = new google.maps.places.Autocomplete(input, {
                fields: ['geometry', 'formatted_address', 'name']
            });

            autocomplete.addListener('place_changed', () => {
                const place = autocomplete.getPlace();
                if (!place.geometry || !place.geometry.location) {
                    log('Destination has no geometry', 'err');
                    return;
                }

                const loc = place.geometry.location;
                destCoords = [loc.lng(), loc.lat()];
                navBtn.disabled = false;
                log('ğŸ“ Destination: ' + (place.formatted_address || place.name || 'Destination'));

                if (destMarker) destMarker.setMap(null);
                destMarker = new google.maps.Marker({
                    map,
                    position: loc,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 6,
                        fillColor: '#ff4466',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2
                    }
                });

                if (currentPos) {
                    fetchAndDrawRoute(currentPos, destCoords, true);
                    fitBoundsToRoute(currentPos, destCoords);
                } else {
                    map.panTo(loc);
                    map.setZoom(14);
                }
            });
        }

        function fitBoundsToRoute(origin, dest) {
            const bounds = new google.maps.LatLngBounds();
            bounds.extend({ lat: origin[1], lng: origin[0] });
            bounds.extend({ lat: dest[1], lng: dest[0] });
            map.fitBounds(bounds, { top: 100, bottom: 260, left: 40, right: 40 });
        }

        function getDirections(request) {
            return new Promise((resolve, reject) => {
                directionsService.route(request, (result, status) => {
                    if (status === 'OK' && result) resolve(result);
                    else reject(new Error(status || 'Directions failed'));
                });
            });
        }

        // Fetch route and draw it. If `previewOnly`, just draw without starting nav.
        async function fetchAndDrawRoute(origin, dest, previewOnly = false) {
            try {
                const request = {
                    origin: { lat: origin[1], lng: origin[0] },
                    destination: { lat: dest[1], lng: dest[0] },
                    travelMode: google.maps.TravelMode.DRIVING,
                };

                const result = await getDirections(request);
                if (!result.routes || !result.routes.length) {
                    log('No route found', 'err');
                    return null;
                }

                const route = result.routes[0];
                drawRoute(route.overview_path);

                if (previewOnly) {
                    let totalDist = 0;
                    let totalDur = 0;
                    for (const leg of route.legs) {
                        totalDist += leg.distance?.value || 0;
                        totalDur += leg.duration?.value || 0;
                    }
                    const mins = Math.max(1, Math.round(totalDur / 60));
                    const km = (totalDist / 1000).toFixed(1);
                    navBtn.textContent = `Navigate (${km} km Â· ${mins} min)`;
                    log(`Route preview: ${km} km, ~${mins} min`);
                }

                return route;
            } catch (e) {
                log('Route error: ' + e.message, 'err');
                return null;
            }
        }

        function drawRoute(path) {
            if (routePolyline) routePolyline.setMap(null);
            routePolyline = new google.maps.Polyline({
                path,
                geodesic: true,
                strokeColor: '#00c8ff',
                strokeOpacity: 0.85,
                strokeWeight: 5
            });
            routePolyline.setMap(map);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  GPS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function updateUserMarker(pos) {
            if (!map || !window.google || !google.maps) return;
            const latLng = { lat: pos.coords.latitude, lng: pos.coords.longitude };

            if (!userMarker) {
                userMarker = new google.maps.Marker({
                    map,
                    position: latLng,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 6,
                        fillColor: '#00c8ff',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2
                    }
                });
            } else {
                userMarker.setPosition(latLng);
            }

            if (!accuracyCircle) {
                accuracyCircle = new google.maps.Circle({
                    map,
                    center: latLng,
                    radius: pos.coords.accuracy || 10,
                    fillColor: '#00c8ff',
                    fillOpacity: 0.12,
                    strokeColor: '#00c8ff',
                    strokeOpacity: 0.35,
                    strokeWeight: 1
                });
            } else {
                accuracyCircle.setCenter(latLng);
                accuracyCircle.setRadius(pos.coords.accuracy || 10);
            }

            if (!hasCentered) {
                map.setCenter(latLng);
                map.setZoom(15);
                hasCentered = true;
            }
        }

        function startGpsWatch() {
            if (!navigator.geolocation) { log('No GPS', 'err'); return; }
            gpsWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    updateUserMarker(pos);
                    if (destCoords && !routePolyline) {
                        fetchAndDrawRoute(currentPos, destCoords, true);
                    }
                    if (navigating) onGpsUpdate();
                },
                (err) => log('GPS error: ' + err.message, 'err'),
                { enableHighAccuracy: true, maximumAge: 2000 }
            );
            log('ğŸ“¡ GPS watch started');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  NAVIGATION ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function startNavigation() {
            if (!currentPos) {
                // Actively request GPS (triggers permission prompt if needed)
                statusText.textContent = 'Requesting GPSâ€¦';
                log('ğŸ“¡ Requesting GPS permissionâ€¦');
                try {
                    const pos = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true, timeout: 10000
                        });
                    });
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    startGpsWatch(); // restart watch now that we have permission
                } catch (e) {
                    alert('Cannot get GPS location. Please allow location access and try again.');
                    statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                    log('GPS denied: ' + e.message, 'err');
                    return;
                }
            }
            if (!destCoords) {
                alert('Please select a destination first');
                return;
            }

            log('ğŸ§­ Starting navigationâ€¦');
            statusText.textContent = 'Calculating routeâ€¦';

            const route = await fetchAndDrawRoute(currentPos, destCoords, false);
            if (!route) {
                alert('No route found');
                statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                return;
            }

            routeGeometry = {
                type: 'LineString',
                coordinates: route.overview_path.map(p => [p.lng(), p.lat()])
            };
            routeSteps = [];

            // Flatten steps from all legs
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    const maneuver = (step.maneuver || 'straight').toLowerCase();
                    const instruction = stripHtml(step.instructions || '');
                    routeSteps.push({
                        maneuver,
                        name: instruction,
                        distance: step.distance?.value || 0,
                        location: [step.end_location.lng(), step.end_location.lat()]
                    });
                }
            }

            let totalDist = 0;
            for (const leg of route.legs) totalDist += leg.distance?.value || 0;
            log(`Route: ${routeSteps.length} steps, ${(totalDist / 1000).toFixed(1)} km`);

            // Start nav mode
            navigating = true;
            navInfo.classList.add('active');
            navBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            $('destSection').style.display = 'none';
            statusText.textContent = 'Navigatingâ€¦';

            // Initial update
            onGpsUpdate();
        }

        function stopNavigation() {
            navigating = false;
            navInfo.classList.remove('active');
            navBtn.style.display = 'block';
            navBtn.textContent = 'Navigate';
            stopBtn.style.display = 'none';
            $('destSection').style.display = 'block';
            statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';

            // Remove route preview
            if (routePolyline) {
                routePolyline.setMap(null);
                routePolyline = null;
            }
            routeGeometry = null;
            routeSteps = null;

            log('â¹ Navigation stopped');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  SNAPPING ENGINE (Turf.js)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function maneuverToIconId(maneuver) {
            const key = (maneuver || '').toLowerCase();
            if (MANEUVER_MAP[key] !== undefined) return MANEUVER_MAP[key];
            if (key.includes('right')) return 2;
            if (key.includes('left')) return 1;
            if (key.includes('uturn')) return 3;
            return 0;
        }

        function buildPreviewPoints(routeLine, snapDist) {
            const lineLength = turf.length(routeLine, { units: 'meters' });
            if (!isFinite(lineLength) || lineLength <= 0) return { count: 0, points: [] };

            const basePoint = turf.along(routeLine, snapDist, { units: 'meters' });
            const aheadPoint = turf.along(routeLine, Math.min(snapDist + 10, lineLength), { units: 'meters' });
            const heading = turf.bearing(basePoint, aheadPoint);
            const lookahead = Math.min(PREVIEW_LOOKAHEAD, Math.max(0, lineLength - snapDist));
            const step = PREVIEW_MAX_POINTS > 1 ? lookahead / (PREVIEW_MAX_POINTS - 1) : 0;
            const points = [];

            for (let i = 0; i < PREVIEW_MAX_POINTS; i++) {
                const d = Math.min(snapDist + step * i, lineLength);
                const p = turf.along(routeLine, d, { units: 'meters' });
                const dist = turf.distance(basePoint, p, { units: 'meters' });
                const bearing = turf.bearing(basePoint, p);
                const rel = (bearing - heading) * Math.PI / 180;
                const x = Math.sin(rel) * dist;
                const y = Math.cos(rel) * dist;
                const scale = PREVIEW_RANGE / PREVIEW_LOOKAHEAD;
                let sx = Math.round(x * scale);
                let sy = Math.round(y * scale);
                sx = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sx));
                sy = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sy));
                points.push({ x: sx, y: sy });
            }

            return { count: points.length, points };
        }

        function onGpsUpdate() {
            if (!currentPos || !routeGeometry || !routeSteps || routeSteps.length === 0) return;

            const routeLine = turf.lineString(routeGeometry.coordinates);
            const pt = turf.point(currentPos);

            // Snap to route
            const snapped = turf.nearestPointOnLine(routeLine, pt, { units: 'meters' });
            const snappedDist = snapped.properties.location; // distance along route in meters (approx from index)

            // Find NEXT step: the one whose maneuver point we haven't passed yet
            let nextStepIdx = 0;

            for (let i = 0; i < routeSteps.length; i++) {
                const stepPt = turf.point(routeSteps[i].location);
                const stepDist = turf.distance(pt, stepPt, { units: 'meters' });

                // If we're within 30m of a step, we've reached it â€” look at the next one
                if (stepDist < 30 && i < routeSteps.length - 1) {
                    nextStepIdx = i + 1;
                    continue;
                }

                // Find next step that's ahead of us
                if (i > nextStepIdx) {
                    // Check if this step's maneuver point is ahead on the route
                    const maneuverPt = turf.point(routeSteps[i].location);
                    const distToManeuver = turf.distance(pt, maneuverPt, { units: 'meters' });

                    if (distToManeuver > 20) {
                        nextStepIdx = i;
                        break;
                    }
                }
            }

            const nextStep = routeSteps[nextStepIdx];
            if (!nextStep) return;

            // Distance from current position to next maneuver
            const maneuverPt = turf.point(nextStep.location);
            const distToTurn = turf.distance(pt, maneuverPt, { units: 'meters' });

            // Map maneuver type â†’ icon_id
            let iconId = maneuverToIconId(nextStep.maneuver);

            // Check for arrival
            if (nextStepIdx === routeSteps.length - 1 && distToTurn < 50) {
                iconId = 4;
            }

            const streetName = nextStep.name || '';
            const preview = buildPreviewPoints(routeLine, snappedDist);

            // Update web UI
            navIcon.textContent = ICON_ARROWS[iconId] || 'â†‘';
            navStreet.textContent = streetName || 'â€”';
            if (distToTurn >= 1000) {
                navDist.textContent = (distToTurn / 1000).toFixed(1);
                navUnit.textContent = 'km';
            } else {
                navDist.textContent = Math.round(distToTurn);
                navUnit.textContent = 'm';
            }

            // Send to ESP32
            sendNavPacket(iconId, distToTurn, streetName, preview);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  API KEY FLOW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const keyOverlay = $('keyOverlay');
        const keyInput = $('keyInput');
        const keyBtn = $('keyBtn');

        function applyKey() {
            const k = keyInput.value.trim();
            if (!k || k.length < 10) {
                alert('Please enter a valid Google Maps API key (starts with AIzaâ€¦)');
                return;
            }
            GOOGLE_MAPS_KEY = k;
            localStorage.setItem('gmaps_key', k);
            keyOverlay.classList.add('hidden');
            loadGoogleMaps(k);
        }

        keyBtn.addEventListener('click', applyKey);
        keyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyKey(); });

        // Auto-init if key already saved
        if (GOOGLE_MAPS_KEY && GOOGLE_MAPS_KEY.length > 10) {
            keyOverlay.classList.add('hidden');
            loadGoogleMaps(GOOGLE_MAPS_KEY);
        } else {
            keyInput.focus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  EVENT LISTENERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        connectBtn.addEventListener('click', bleConnect);
        navBtn.addEventListener('click', startNavigation);
        stopBtn.addEventListener('click', stopNavigation);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('ğŸ“± App backgrounded');
            } else {
                log('ğŸ“± App foregrounded');
            }
        });

        window.addEventListener('load', () => {
            if (!navigator.bluetooth) {
                log('âš ï¸ Web Bluetooth not available â€” use Bluefy or Chrome HTTPS', 'err');
            } else {
                log('âœ… Web Bluetooth ready');
            }
        });
    </script>
</body>

</html>
