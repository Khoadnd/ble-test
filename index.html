<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MotoHUD Navigator</title>
    <meta name="description" content="Motorcycle HUD Navigation Brain â€” TomTom + BLE">

    <!-- Leaflet (map rendering) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Turf.js -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #00c8ff;
            --accent-dim: rgba(0, 200, 255, 0.15);
            --bg: #0a0e1a;
            --card: #141828;
            --card-border: #1e2540;
            --text: #e8eaf0;
            --text-dim: #6b7394;
            --success: #00e878;
            --danger: #ff4466;
            --radius: 14px;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        /* â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
        }

        .mini-map-wrap {
            position: absolute;
            top: 110px;
            right: 16px;
            width: 148px;
            height: 148px;
            border-radius: 50%;
            overflow: hidden;
            z-index: 200;
            pointer-events: none;
            box-shadow: 0 18px 35px rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.06), rgba(10, 14, 26, 0.9));
        }

        .mini-map-wrap::after {
            content: "";
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.35);
            pointer-events: none;
        }

        .mini-map {
            width: 100%;
            height: 100%;
            filter: saturate(1.1) contrast(1.05);
        }

        .mini-compass {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-bottom: 18px solid rgba(0, 200, 255, 0.95);
            transform: translate(-50%, -50%) rotate(0deg);
            filter: drop-shadow(0 0 6px rgba(0, 200, 255, 0.6));
        }

        .mini-compass::after {
            content: "";
            position: absolute;
            left: -2px;
            top: 16px;
            width: 4px;
            height: 10px;
            background: rgba(0, 200, 255, 0.6);
            border-radius: 2px;
        }

        /* â”€â”€ Top Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 50px 16px 12px;
            background: linear-gradient(to bottom, rgba(10, 14, 26, 0.95) 60%, transparent);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ble-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger);
            flex-shrink: 0;
            transition: background 0.3s;
            box-shadow: 0 0 8px var(--danger);
        }

        .ble-indicator.connected {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .top-bar .status-text {
            font-size: 13px;
            color: var(--text-dim);
            flex: 1;
        }

        /* â”€â”€ Bottom Sheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card);
            border-top: 1px solid var(--card-border);
            border-radius: 20px 20px 0 0;
            padding: 16px 16px calc(12px + var(--safe-bottom));
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .sheet-handle {
            width: 36px;
            height: 4px;
            background: var(--card-border);
            border-radius: 2px;
            margin: 0 auto 14px;
        }

        /* â”€â”€ Nav Info (shown during navigation) â”€â”€ */
        .nav-info {
            display: none;
            text-align: center;
            margin-bottom: 14px;
        }

        .nav-info.active {
            display: block;
        }

        .nav-icon {
            font-size: 42px;
            margin-bottom: 4px;
        }

        .nav-street {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nav-distance {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent);
        }

        .nav-unit {
            font-size: 14px;
            color: var(--text-dim);
            margin-left: 4px;
        }

        /* â”€â”€ Destination input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .dest-section {
            margin-bottom: 12px;
        }

        .dest-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }

        .dest-input:focus {
            border-color: var(--accent);
        }

        .dest-input::placeholder {
            color: var(--text-dim);
        }

        .dest-suggestions {
            display: none;
            margin-top: 8px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            max-height: 180px;
            overflow-y: auto;
        }

        .dest-suggestions.open {
            display: block;
        }

        .suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--card-border);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background: var(--accent-dim);
        }

        .suggestion-title {
            font-size: 14px;
            font-weight: 600;
        }

        .suggestion-sub {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: var(--radius);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-bottom: 8px;
        }

        .btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            transform: none;
        }

        .btn-connect {
            background: linear-gradient(135deg, #0066ff, #0099ff);
            color: white;
        }

        .btn-navigate {
            background: linear-gradient(135deg, #00b856, #00e878);
            color: white;
        }

        .btn-stop {
            background: var(--danger);
            color: white;
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn-row .btn {
            flex: 1;
        }

        /* â”€â”€ Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .log-toggle {
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
            padding: 6px;
            cursor: pointer;
        }

        .log-panel {
            display: none;
            max-height: 150px;
            overflow-y: auto;
            background: var(--bg);
            border-radius: 10px;
            padding: 10px;
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .log-panel.open {
            display: block;
        }

        .log-entry {
            padding: 3px 0;
            color: var(--text-dim);
        }

        .log-entry.sent {
            color: #3498db;
        }

        .log-entry.recv {
            color: var(--success);
        }

        .log-entry.err {
            color: var(--danger);
        }

        /* â”€â”€ Token Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .token-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.97);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .token-overlay.hidden {
            display: none;
        }

        .token-card {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 400px;
            width: 100%;
        }

        .token-card h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }

        .token-card p {
            font-size: 13px;
            color: var(--text-dim);
            margin-bottom: 16px;
        }

        .token-card input {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            color: var(--text);
            font-size: 14px;
            font-family: 'SF Mono', monospace;
            outline: none;
            margin-bottom: 12px;
        }

        .token-card input:focus {
            border-color: var(--accent);
        }

        .leaflet-control-attribution {
            background: rgba(10, 14, 26, 0.65);
            color: var(--text-dim);
            font-size: 10px;
        }

        .leaflet-control-attribution a {
            color: var(--text-dim);
        }

    </style>
</head>

<body>

    <!-- â•â•â•â• TOKEN OVERLAY â•â•â•â• -->
    <div class="token-overlay" id="keyOverlay">
        <div class="token-card">
            <h2>ğŸ—ºï¸ TomTom API Key</h2>
            <p>Paste your TomTom API key. It will be saved in your browser for next time.</p>
            <input type="text" id="keyInput" placeholder="TomTomKey..." autocomplete="off" spellcheck="false">
            <button class="btn btn-connect" id="keyBtn">Start Map</button>
        </div>
    </div>

    <!-- â•â•â•â• MAP â•â•â•â• -->
    <div id="map"></div>
    <div class="mini-map-wrap" id="miniMapWrap">
        <div class="mini-map" id="miniMap"></div>
        <div class="mini-compass" id="miniCompass"></div>
    </div>

    <!-- â•â•â•â• TOP BAR â•â•â•â• -->
    <div class="top-bar">
        <div class="ble-indicator" id="bleIndicator"></div>
        <span class="status-text" id="statusText">Tap Connect to pair with MotoHUD</span>
    </div>

    <!-- â•â•â•â• BOTTOM SHEET â•â•â•â• -->
    <div class="bottom-sheet">
        <div class="sheet-handle"></div>

        <!-- Nav info (visible during navigation) -->
        <div class="nav-info" id="navInfo">
            <div class="nav-icon" id="navIcon">â†‘</div>
            <div class="nav-street" id="navStreet">â€”</div>
            <div>
                <span class="nav-distance" id="navDist">--</span>
                <span class="nav-unit" id="navUnit"></span>
            </div>
        </div>

        <!-- Destination search -->
        <div class="dest-section" id="destSection">
            <input class="dest-input" id="destInput" type="text" placeholder="Where to?" autocomplete="off">
            <div class="dest-suggestions" id="destSuggestions"></div>
        </div>

        <!-- Buttons -->
        <div id="connectRow">
            <button class="btn btn-connect" id="connectBtn">ğŸ”µ Connect to MotoHUD</button>
        </div>
        <div id="navRow" style="display:none;">
            <div class="btn-row">
                <button class="btn btn-navigate" id="navBtn" disabled>Navigate</button>
                <button class="btn btn-stop" id="stopBtn" style="display:none;">Stop</button>
            </div>
        </div>

        <!-- Log -->
        <div class="log-toggle" id="logToggle">â–¼ Show Log</div>
        <div class="log-panel" id="logPanel"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let TOMTOM_KEY = localStorage.getItem('tomtom_key') || '';

        // BLE UUIDs â€” must match ESP32 firmware
        const BLE_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
        const BLE_NAV_CHAR_UUID = '12345678-1234-1234-1234-123456789abd';
        const BLE_DEVICE_NAME = 'MotoHUD';

        // Nav update rate (ms)
        const NAV_UPDATE_INTERVAL = 250;

        // Maneuver icon map â†’ icon_id for ESP32
        const MANEUVER_MAP = {
            'DEPART': 0,
            'STRAIGHT': 0,
            'KEEP_LEFT': 1,
            'BEAR_LEFT': 1,
            'TURN_LEFT': 1,
            'SHARP_LEFT': 1,
            'EXIT_LEFT': 1,
            'ROUNDABOUT_LEFT': 1,
            'KEEP_RIGHT': 2,
            'BEAR_RIGHT': 2,
            'TURN_RIGHT': 2,
            'SHARP_RIGHT': 2,
            'EXIT_RIGHT': 2,
            'ROUNDABOUT_RIGHT': 2,
            'MAKE_UTURN': 3,
            'UTURN_LEFT': 3,
            'UTURN_RIGHT': 3,
            'ARRIVE': 4,
            'ARRIVE_LEFT': 4,
            'ARRIVE_RIGHT': 4,
            'ENTER_MOTORWAY': 0,
            'EXIT_MOTORWAY': 0,
            'TAKE_EXIT': 0,
            'MERGE': 0,
            'ROUNDABOUT_CROSS': 0,
            'FERRY': 0,
            'RAIL_FERRY': 0,
            'PARKING': 0
        };

        const ICON_ARROWS = ['â†‘', 'â†', 'â†’', 'â†©', 'âœ“'];
        const PREVIEW_MAX_POINTS = 6;
        const PREVIEW_LOOKAHEAD = 200; // meters
        const PREVIEW_RANGE = 50; // coordinate range (-50..50)

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let bleDevice = null, bleChar = null, bleConnected = false;
        let map, userMarker, accuracyCircle, gpsWatchId = null;
        let routePolyline = null;
        let destMarker = null;
        let hasCentered = false;
        let miniMap = null;
        let miniRoute = null;
        let miniUserMarker = null;
        let miniDestMarker = null;
        let compassHeading = null;
        let currentPos = null;
        let routeGeometry = null, routeSteps = null;
        let navigating = false, navTimer = null;
        let destCoords = null;
        let lastSendTime = 0;
        let isWriting = false;
        let suggestionResults = [];
        let suggestTimer = null;
        let suggestAbort = null;

        // Background audio keep-alive
        let silentAudio = new Audio();
        silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAASAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAATMOpAAAAAABhAAaAAAAABzsDPwMHAwADAwMAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA';
        silentAudio.loop = true;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  DOM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const $ = id => document.getElementById(id);
        const bleIndicator = $('bleIndicator');
        const statusText = $('statusText');
        const connectBtn = $('connectBtn');
        const navBtn = $('navBtn');
        const stopBtn = $('stopBtn');
        const navInfo = $('navInfo');
        const navIcon = $('navIcon');
        const navStreet = $('navStreet');
        const navDist = $('navDist');
        const navUnit = $('navUnit');
        const destInput = $('destInput');
        const destSuggestions = $('destSuggestions');
        const miniCompass = $('miniCompass');
        const logPanel = $('logPanel');
        const logToggle = $('logToggle');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  LOG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function log(msg, type = '') {
            const ts = new Date().toLocaleTimeString('en-US', { hour12: false });
            const el = document.createElement('div');
            el.className = 'log-entry ' + type;
            el.textContent = `[${ts}] ${msg}`;
            logPanel.appendChild(el);
            logPanel.scrollTop = logPanel.scrollHeight;
            // keep max 100 entries
            while (logPanel.children.length > 100) logPanel.removeChild(logPanel.firstChild);
        }

        logToggle.onclick = () => {
            logPanel.classList.toggle('open');
            logToggle.textContent = logPanel.classList.contains('open') ? 'â–² Hide Log' : 'â–¼ Show Log';
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE  â€” Web Bluetooth
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function bleConnect() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth not available.\nUse Bluefy on iOS or Chrome on Android with HTTPS.');
                return;
            }

            try {
                // Start background audio (needs user gesture)
                silentAudio.play().then(() => {
                    log('ğŸµ Background audio started');
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: 'MotoHUD Active', artist: 'Navigation', album: 'Background Mode',
                        });
                        navigator.mediaSession.setActionHandler('play', () => silentAudio.play());
                        navigator.mediaSession.setActionHandler('pause', () => silentAudio.play());
                    }
                }).catch(e => log('Audio: ' + e.message, 'err'));

                silentAudio.onpause = () => {
                    silentAudio.play().catch(() => { });
                };

                statusText.textContent = 'Scanning for MotoHUDâ€¦';
                log('Requesting BLE deviceâ€¦');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: BLE_DEVICE_NAME }],
                    optionalServices: [BLE_SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onBleDisconnect);

                // Bluefy helpers
                if (navigator.bluetooth.setScreenDimEnabled) {
                    try { navigator.bluetooth.setScreenDimEnabled(false); } catch (_) { }
                }

                statusText.textContent = 'Connectingâ€¦';
                const server = await bleDevice.gatt.connect();
                const service = await server.getPrimaryService(BLE_SERVICE_UUID);
                bleChar = await service.getCharacteristic(BLE_NAV_CHAR_UUID);

                bleConnected = true;
                bleIndicator.classList.add('connected');
                statusText.textContent = 'Connected to MotoHUD';
                connectBtn.textContent = 'ğŸ”µ Connected';
                connectBtn.disabled = true;
                $('navRow').style.display = 'block';

                log('âœ… BLE connected');

            } catch (e) {
                log('BLE error: ' + (e.message || e), 'err');
                statusText.textContent = 'Connection failed â€” tap to retry';
                silentAudio.pause();
            }
        }

        function onBleDisconnect() {
            bleConnected = false;
            bleChar = null;
            bleIndicator.classList.remove('connected');
            statusText.textContent = 'Disconnected â€” tap Connect';
            connectBtn.textContent = 'ğŸ”µ Connect to MotoHUD';
            connectBtn.disabled = false;
            log('âŒ BLE disconnected');
            if (navigating) stopNavigation();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE â€” NavPacket sender
        //  Struct: {
        //    uint8  icon_id,
        //    uint32 dist_meters (LE),
        //    char   street[32],
        //    uint8  preview_count,
        //    int8   preview_xy[12] (6 points: x,y),
        //    uint16 heading_deg (0-359, LE)
        //  }
        //  Total: 52 bytes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Strip Vietnamese diacritics â†’ ASCII (ESP32 fonts are Latin-only)
        function stripDiacritics(str) {
            // Vietnamese-specific replacements for Ä‘/Ä (not handled by NFD)
            str = str.replace(/Ä‘/g, 'd').replace(/Ä/g, 'D');
            // NFD decompose then strip combining marks
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        // Truncate a string so its UTF-8 encoding fits within maxBytes
        function truncateToBytes(str, maxBytes) {
            const encoder = new TextEncoder();
            let encoded = encoder.encode(str);
            if (encoded.length <= maxBytes) return encoded;
            // Binary search for longest substring that fits
            let lo = 0, hi = str.length;
            while (lo < hi) {
                const mid = (lo + hi + 1) >> 1;
                if (encoder.encode(str.substring(0, mid)).length <= maxBytes) {
                    lo = mid;
                } else {
                    hi = mid - 1;
                }
            }
            return encoder.encode(str.substring(0, lo));
        }

        function stripHtml(html) {
            return (html || '').replace(/<[^>]+>/g, '').trim();
        }

        const PREVIEW_BYTES = PREVIEW_MAX_POINTS * 2;
        const STREET_MAX_BYTES = 32;
        const PREVIEW_COUNT_OFFSET = 1 + 4 + STREET_MAX_BYTES;
        const PREVIEW_DATA_OFFSET = PREVIEW_COUNT_OFFSET + 1;
        const HEADING_OFFSET = PREVIEW_DATA_OFFSET + PREVIEW_BYTES;
        const PACKET_SIZE = HEADING_OFFSET + 2;

        async function sendNavPacket(iconId, distMeters, street, preview, headingDeg) {
            if (!bleChar || !bleConnected || isWriting) return;

            const now = Date.now();
            if (now - lastSendTime < NAV_UPDATE_INTERVAL) return;
            lastSendTime = now;

            isWriting = true;
            try {
                const buf = new ArrayBuffer(PACKET_SIZE);
                const dv = new DataView(buf);
                dv.setUint8(0, iconId);
                dv.setUint32(1, Math.round(distMeters), true); // little-endian

                // Strip diacritics for ESP32 display, truncate to fit 32 bytes
                const ascii = stripDiacritics(street || '');
                const streetBytes = truncateToBytes(ascii, STREET_MAX_BYTES);
                const u8 = new Uint8Array(buf);
                u8.set(streetBytes, 5);   // rest is zero-padded by ArrayBuffer

                const previewCount = Math.min(PREVIEW_MAX_POINTS, preview?.count || 0);
                dv.setUint8(PREVIEW_COUNT_OFFSET, previewCount);
                const previewOffset = PREVIEW_DATA_OFFSET;
                for (let i = 0; i < PREVIEW_MAX_POINTS; i++) {
                    const idx = i * 2;
                    const px = preview?.points?.[i]?.x ?? 0;
                    const py = preview?.points?.[i]?.y ?? 0;
                    dv.setInt8(previewOffset + idx, px);
                    dv.setInt8(previewOffset + idx + 1, py);
                }

                const heading = Math.max(0, Math.min(359, Math.round(headingDeg || 0)));
                dv.setUint16(HEADING_OFFSET, heading, true);

                await bleChar.writeValueWithoutResponse(buf);
            } catch (e) {
                log('Send error: ' + e.message, 'err');
            } finally {
                isWriting = false;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  MAP â€” TomTom + Leaflet
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initMap() {
            if (map) {
                map.remove();
                map = null;
            }
            map = L.map('map', {
                zoomControl: false,
                attributionControl: true
            });

            userMarker = null;
            accuracyCircle = null;
            routePolyline = null;
            destMarker = null;
            hasCentered = false;

            const tileUrl = `https://{s}.api.tomtom.com/map/1/tile/basic/night/{z}/{x}/{y}.png?key=${encodeURIComponent(TOMTOM_KEY)}`;
            L.tileLayer(tileUrl, {
                maxZoom: 22,
                subdomains: 'abcd',
                tileSize: 256,
                attribution: 'Â© TomTom'
            }).addTo(map);

            map.setView([10.7769, 106.7009], 13);
            initMiniMap(tileUrl);
            setupAutocomplete();
            startGpsWatch();
            log('ğŸ—ºï¸ Map initialized');
        }

        function initMiniMap(tileUrl) {
            if (miniMap) {
                miniMap.remove();
                miniMap = null;
            }

            miniMap = L.map('miniMap', {
                zoomControl: false,
                attributionControl: false,
                dragging: false,
                scrollWheelZoom: false,
                doubleClickZoom: false,
                boxZoom: false,
                keyboard: false,
                touchZoom: false,
                zoomSnap: 0
            });

            if (miniMap.tap) miniMap.tap.disable();

            L.tileLayer(tileUrl, {
                maxZoom: 22,
                subdomains: 'abcd',
                tileSize: 256
            }).addTo(miniMap);

            miniMap.setView([10.7769, 106.7009], 16);
            miniRoute = null;
            miniUserMarker = null;
            miniDestMarker = null;
        }

        function setupAutocomplete() {
            destInput.addEventListener('input', () => {
                const q = destInput.value.trim();
                clearTimeout(suggestTimer);
                if (q.length < 2) {
                    renderSuggestions([]);
                    return;
                }
                suggestTimer = setTimeout(() => fetchSuggestions(q), 250);
            });

            destInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const q = destInput.value.trim();
                    if (!q) return;
                    if (suggestionResults.length > 0) {
                        selectSuggestion(suggestionResults[0]);
                    } else {
                        fetchSuggestions(q, true);
                    }
                }
            });

            destInput.addEventListener('blur', () => {
                setTimeout(() => renderSuggestions([]), 150);
            });

            destSuggestions.addEventListener('click', (e) => {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;
                const idx = Number(item.dataset.idx);
                const result = suggestionResults[idx];
                if (result) selectSuggestion(result);
            });
        }

        async function fetchSuggestions(query, pickFirst = false) {
            if (!TOMTOM_KEY || !query) return;

            if (suggestAbort) suggestAbort.abort();
            suggestAbort = new AbortController();

            try {
                const params = new URLSearchParams({
                    key: TOMTOM_KEY,
                    typeahead: 'true',
                    limit: '6',
                    countrySet: 'VN'
                });
                if (currentPos) {
                    params.set('lat', currentPos[1].toFixed(6));
                    params.set('lon', currentPos[0].toFixed(6));
                }

                const url = `https://api.tomtom.com/search/2/search/${encodeURIComponent(query)}.json?${params.toString()}`;
                const res = await fetch(url, { signal: suggestAbort.signal });
                const data = await res.json();
                const results = data.results || [];
                if (pickFirst && results.length > 0) {
                    selectSuggestion(results[0]);
                    return;
                }
                renderSuggestions(results);
            } catch (e) {
                if (e.name !== 'AbortError') {
                    log('Search error: ' + e.message, 'err');
                }
            }
        }

        function renderSuggestions(results) {
            suggestionResults = results || [];
            destSuggestions.innerHTML = '';
            if (!suggestionResults.length) {
                destSuggestions.classList.remove('open');
                return;
            }

            suggestionResults.forEach((r, idx) => {
                const title = r.poi?.name || r.address?.freeformAddress || 'Result';
                const sub = r.address?.freeformAddress || r.address?.municipality || r.address?.countrySubdivision || '';
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.dataset.idx = String(idx);

                const t = document.createElement('div');
                t.className = 'suggestion-title';
                t.textContent = title;
                item.appendChild(t);

                if (sub && sub !== title) {
                    const s = document.createElement('div');
                    s.className = 'suggestion-sub';
                    s.textContent = sub;
                    item.appendChild(s);
                }

                destSuggestions.appendChild(item);
            });

            destSuggestions.classList.add('open');
        }

        function selectSuggestion(result) {
            if (!result || !result.position) return;
            const { lat, lon } = result.position;
            destCoords = [lon, lat];
            const label = result.address?.freeformAddress || result.poi?.name || 'Destination';
            destInput.value = label;
            navBtn.disabled = false;
            renderSuggestions([]);
            log('ğŸ“ Destination: ' + label);

            if (destMarker) map.removeLayer(destMarker);
            destMarker = L.circleMarker([lat, lon], {
                radius: 6,
                color: '#ffffff',
                weight: 2,
                fillColor: '#ff4466',
                fillOpacity: 1
            }).addTo(map);

            if (miniMap) {
                if (miniDestMarker) miniMap.removeLayer(miniDestMarker);
                miniDestMarker = L.circleMarker([lat, lon], {
                    radius: 4,
                    color: '#ffffff',
                    weight: 1,
                    fillColor: '#ff4466',
                    fillOpacity: 1
                }).addTo(miniMap);
            }

            if (currentPos) {
                fetchAndDrawRoute(currentPos, destCoords, true);
                fitBoundsToRoute(currentPos, destCoords);
            } else {
                map.setView([lat, lon], 14);
            }
        }

        function fitBoundsToRoute(origin, dest) {
            const bounds = L.latLngBounds(
                [origin[1], origin[0]],
                [dest[1], dest[0]]
            );
            map.fitBounds(bounds, { padding: [40, 160] });
        }

        // Fetch route and draw it. If `previewOnly`, just draw without starting nav.
        async function fetchAndDrawRoute(origin, dest, previewOnly = false) {
            try {
                if (!TOMTOM_KEY) {
                    log('Missing TomTom API key', 'err');
                    return null;
                }
                const params = new URLSearchParams({
                    key: TOMTOM_KEY,
                    travelMode: 'car',
                    instructionsType: 'coded',
                    language: 'en-US',
                    routeRepresentation: 'polyline',
                    computeTravelTimeFor: 'all',
                    traffic: 'true'
                });
                const url = `https://api.tomtom.com/routing/1/calculateRoute/${origin[1]},${origin[0]}:${dest[1]},${dest[0]}/json?${params.toString()}`;

                const res = await fetch(url);
                const data = await res.json();
                if (!data.routes || !data.routes.length) {
                    log('No route found', 'err');
                    return null;
                }

                const route = data.routes[0];
                const leg = route.legs?.[0];
                const points = leg?.points || [];
                const geometry = points.map(p => [p.longitude, p.latitude]);
                drawRoute(geometry);

                if (previewOnly) {
                    const meters = route.summary?.lengthInMeters || 0;
                    const mins = Math.max(1, Math.round((route.summary?.travelTimeInSeconds || 0) / 60));
                    const km = (meters / 1000).toFixed(1);
                    navBtn.textContent = `Navigate (${km} km Â· ${mins} min)`;
                    log(`Route preview: ${km} km, ~${mins} min`);
                }

                return { route, geometry };
            } catch (e) {
                log('Route error: ' + e.message, 'err');
                return null;
            }
        }

        function drawRoute(coords) {
            if (routePolyline) map.removeLayer(routePolyline);
            const latLngs = coords.map(c => [c[1], c[0]]);
            routePolyline = L.polyline(latLngs, {
                color: '#00c8ff',
                weight: 5,
                opacity: 0.85
            }).addTo(map);

            if (miniMap) {
                if (miniRoute) miniMap.removeLayer(miniRoute);
                miniRoute = L.polyline(latLngs, {
                    color: '#00c8ff',
                    weight: 3,
                    opacity: 0.9
                }).addTo(miniMap);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  GPS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function updateUserMarker(pos) {
            if (!map) return;
            const latLng = [pos.coords.latitude, pos.coords.longitude];

            if (!userMarker) {
                userMarker = L.circleMarker(latLng, {
                    radius: 6,
                    color: '#ffffff',
                    weight: 2,
                    fillColor: '#00c8ff',
                    fillOpacity: 1
                }).addTo(map);
            } else {
                userMarker.setLatLng(latLng);
            }

            if (!accuracyCircle) {
                accuracyCircle = L.circle(latLng, {
                    radius: pos.coords.accuracy || 10,
                    color: '#00c8ff',
                    weight: 1,
                    opacity: 0.35,
                    fillColor: '#00c8ff',
                    fillOpacity: 0.12
                }).addTo(map);
            } else {
                accuracyCircle.setLatLng(latLng);
                accuracyCircle.setRadius(pos.coords.accuracy || 10);
            }

            if (!hasCentered) {
                map.setView(latLng, 15);
                hasCentered = true;
            }

            if (miniMap) {
                if (!miniUserMarker) {
                    miniUserMarker = L.circleMarker(latLng, {
                        radius: 4,
                        color: '#ffffff',
                        weight: 1,
                        fillColor: '#00c8ff',
                        fillOpacity: 1
                    }).addTo(miniMap);
                } else {
                    miniUserMarker.setLatLng(latLng);
                }
                miniMap.setView(latLng, 16, { animate: false });
            }

            if (Number.isFinite(pos.coords.heading)) {
                setCompassHeading(pos.coords.heading);
            }
        }

        function startGpsWatch() {
            if (!navigator.geolocation) { log('No GPS', 'err'); return; }
            gpsWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    updateUserMarker(pos);
                    if (destCoords && !routePolyline) {
                        fetchAndDrawRoute(currentPos, destCoords, true);
                    }
                    if (navigating) onGpsUpdate();
                },
                (err) => log('GPS error: ' + err.message, 'err'),
                { enableHighAccuracy: true, maximumAge: 2000 }
            );
            log('ğŸ“¡ GPS watch started');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  NAVIGATION ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function startNavigation() {
            if (!currentPos) {
                // Actively request GPS (triggers permission prompt if needed)
                statusText.textContent = 'Requesting GPSâ€¦';
                log('ğŸ“¡ Requesting GPS permissionâ€¦');
                try {
                    const pos = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true, timeout: 10000
                        });
                    });
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    startGpsWatch(); // restart watch now that we have permission
                } catch (e) {
                    alert('Cannot get GPS location. Please allow location access and try again.');
                    statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                    log('GPS denied: ' + e.message, 'err');
                    return;
                }
            }
            if (!destCoords) {
                alert('Please select a destination first');
                return;
            }

            log('ğŸ§­ Starting navigationâ€¦');
            statusText.textContent = 'Calculating routeâ€¦';

            const result = await fetchAndDrawRoute(currentPos, destCoords, false);
            if (!result) {
                alert('No route found');
                statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                return;
            }

            const route = result.route;
            routeGeometry = {
                type: 'LineString',
                coordinates: result.geometry
            };
            routeSteps = [];

            const instructions = route.guidance?.instructions || [];
            for (const instr of instructions) {
                if (!instr.point) continue;
                const name = instr.street || instr.signpostText || instr.roadNumbers?.[0] || instr.message || '';
                routeSteps.push({
                    maneuver: instr.maneuver || 'STRAIGHT',
                    name: stripHtml(name),
                    location: [instr.point.longitude, instr.point.latitude],
                    turnAngle: instr.turnAngleInDecimalDegrees || 0
                });
            }

            if (routeSteps.length === 0 && result.geometry.length) {
                const last = result.geometry[result.geometry.length - 1];
                routeSteps.push({
                    maneuver: 'ARRIVE',
                    name: 'Destination',
                    location: last,
                    turnAngle: 0
                });
            }

            const totalDist = route.summary?.lengthInMeters || 0;
            log(`Route: ${routeSteps.length} steps, ${(totalDist / 1000).toFixed(1)} km`);

            // Start nav mode
            navigating = true;
            navInfo.classList.add('active');
            navBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            $('destSection').style.display = 'none';
            statusText.textContent = 'Navigatingâ€¦';

            // Initial update
            onGpsUpdate();
        }

        function stopNavigation() {
            navigating = false;
            navInfo.classList.remove('active');
            navBtn.style.display = 'block';
            navBtn.textContent = 'Navigate';
            stopBtn.style.display = 'none';
            $('destSection').style.display = 'block';
            statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';

            // Remove route preview
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            if (miniRoute && miniMap) {
                miniMap.removeLayer(miniRoute);
                miniRoute = null;
            }
            routeGeometry = null;
            routeSteps = null;

            log('â¹ Navigation stopped');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  SNAPPING ENGINE (Turf.js)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function maneuverToIconId(step) {
            const key = (step?.maneuver || '').toUpperCase();
            if (MANEUVER_MAP[key] !== undefined) return MANEUVER_MAP[key];
            const angle = step?.turnAngle || 0;
            if (angle > 15) return 2;
            if (angle < -15) return 1;
            return 0;
        }

        function setCompassHeading(deg) {
            if (!miniCompass) return;
            const normalized = ((deg % 360) + 360) % 360;
            compassHeading = normalized;
            miniCompass.style.transform = `translate(-50%, -50%) rotate(${normalized}deg)`;
        }

        function handleOrientation(event) {
            let heading = null;
            if (typeof event.webkitCompassHeading === 'number') {
                heading = event.webkitCompassHeading;
            } else if (typeof event.alpha === 'number') {
                heading = 360 - event.alpha;
            }
            if (heading !== null && !Number.isNaN(heading)) {
                setCompassHeading(heading);
            }
        }

        async function requestOrientationPermission() {
            if (typeof DeviceOrientationEvent === 'undefined') return;
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const res = await DeviceOrientationEvent.requestPermission();
                    if (res === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                    }
                } catch (e) {
                    log('Compass permission denied', 'err');
                }
            } else {
                window.addEventListener('deviceorientationabsolute', handleOrientation, true);
                window.addEventListener('deviceorientation', handleOrientation, true);
            }
        }

        function buildPreviewPoints(routeLine, snapDist) {
            const lineLength = turf.length(routeLine, { units: 'meters' });
            if (!isFinite(lineLength) || lineLength <= 0) return { count: 0, points: [] };

            const basePoint = turf.along(routeLine, snapDist, { units: 'meters' });
            const aheadPoint = turf.along(routeLine, Math.min(snapDist + 10, lineLength), { units: 'meters' });
            const heading = turf.bearing(basePoint, aheadPoint);
            const lookahead = Math.min(PREVIEW_LOOKAHEAD, Math.max(0, lineLength - snapDist));
            const step = PREVIEW_MAX_POINTS > 1 ? lookahead / (PREVIEW_MAX_POINTS - 1) : 0;
            const points = [];

            for (let i = 0; i < PREVIEW_MAX_POINTS; i++) {
                const d = Math.min(snapDist + step * i, lineLength);
                const p = turf.along(routeLine, d, { units: 'meters' });
                const dist = turf.distance(basePoint, p, { units: 'meters' });
                const bearing = turf.bearing(basePoint, p);
                const rel = (bearing - heading) * Math.PI / 180;
                const x = Math.sin(rel) * dist;
                const y = Math.cos(rel) * dist;
                const scale = PREVIEW_RANGE / PREVIEW_LOOKAHEAD;
                let sx = Math.round(x * scale);
                let sy = Math.round(y * scale);
                sx = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sx));
                sy = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sy));
                points.push({ x: sx, y: sy });
            }

            return { count: points.length, points };
        }

        function onGpsUpdate() {
            if (!currentPos || !routeGeometry || !routeSteps || routeSteps.length === 0) return;

            const routeLine = turf.lineString(routeGeometry.coordinates);
            const pt = turf.point(currentPos);

            // Snap to route
            const snapped = turf.nearestPointOnLine(routeLine, pt, { units: 'meters' });
            const snappedDist = snapped.properties.location; // distance along route in meters (approx from index)

            // Find NEXT step: the one whose maneuver point we haven't passed yet
            let nextStepIdx = 0;

            for (let i = 0; i < routeSteps.length; i++) {
                const stepPt = turf.point(routeSteps[i].location);
                const stepDist = turf.distance(pt, stepPt, { units: 'meters' });

                // If we're within 30m of a step, we've reached it â€” look at the next one
                if (stepDist < 30 && i < routeSteps.length - 1) {
                    nextStepIdx = i + 1;
                    continue;
                }

                // Find next step that's ahead of us
                if (i > nextStepIdx) {
                    // Check if this step's maneuver point is ahead on the route
                    const maneuverPt = turf.point(routeSteps[i].location);
                    const distToManeuver = turf.distance(pt, maneuverPt, { units: 'meters' });

                    if (distToManeuver > 20) {
                        nextStepIdx = i;
                        break;
                    }
                }
            }

            const nextStep = routeSteps[nextStepIdx];
            if (!nextStep) return;

            // Distance from current position to next maneuver
            const maneuverPt = turf.point(nextStep.location);
            const distToTurn = turf.distance(pt, maneuverPt, { units: 'meters' });

            // Map maneuver type â†’ icon_id
            let iconId = maneuverToIconId(nextStep);

            // Check for arrival
            const maneuverKey = (nextStep.maneuver || '').toUpperCase();
            if (maneuverKey.startsWith('ARRIVE') || (nextStepIdx === routeSteps.length - 1 && distToTurn < 50)) {
                iconId = 4;
            }

            const streetName = nextStep.name || '';
            const preview = buildPreviewPoints(routeLine, snappedDist);
            const headingToSend = compassHeading ?? 0;

            // Update web UI
            navIcon.textContent = ICON_ARROWS[iconId] || 'â†‘';
            navStreet.textContent = streetName || 'â€”';
            if (distToTurn >= 1000) {
                navDist.textContent = (distToTurn / 1000).toFixed(1);
                navUnit.textContent = 'km';
            } else {
                navDist.textContent = Math.round(distToTurn);
                navUnit.textContent = 'm';
            }

            // Send to ESP32
            sendNavPacket(iconId, distToTurn, streetName, preview, headingToSend);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  API KEY FLOW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const keyOverlay = $('keyOverlay');
        const keyInput = $('keyInput');
        const keyBtn = $('keyBtn');

        function applyKey() {
            const k = keyInput.value.trim();
            if (!k || k.length < 10) {
                alert('Please enter a valid TomTom API key');
                return;
            }
            TOMTOM_KEY = k;
            localStorage.setItem('tomtom_key', k);
            keyOverlay.classList.add('hidden');
            initMap();
            requestOrientationPermission();
        }

        keyBtn.addEventListener('click', applyKey);
        keyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyKey(); });

        // Auto-init if key already saved
        if (TOMTOM_KEY && TOMTOM_KEY.length > 10) {
            keyOverlay.classList.add('hidden');
            initMap();
        } else {
            keyInput.focus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  EVENT LISTENERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        connectBtn.addEventListener('click', bleConnect);
        connectBtn.addEventListener('click', requestOrientationPermission);
        navBtn.addEventListener('click', startNavigation);
        stopBtn.addEventListener('click', stopNavigation);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('ğŸ“± App backgrounded');
            } else {
                log('ğŸ“± App foregrounded');
            }
        });

        window.addEventListener('load', () => {
            if (!navigator.bluetooth) {
                log('âš ï¸ Web Bluetooth not available â€” use Bluefy or Chrome HTTPS', 'err');
            } else {
                log('âœ… Web Bluetooth ready');
            }
        });
    </script>
</body>

</html>
