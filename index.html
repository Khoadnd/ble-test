<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MotoHUD Navigator</title>
    <meta name="description" content="Motorcycle HUD Navigation Brain â€” TomTom + BLE">

    <!-- Leaflet (map rendering) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Turf.js -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <!-- Vector tiles -->
    <script src="https://cdn.jsdelivr.net/npm/pbf@3.2.1/dist/pbf.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #00c8ff;
            --accent-dim: rgba(0, 200, 255, 0.15);
            --bg: #0a0e1a;
            --card: #141828;
            --card-border: #1e2540;
            --text: #e8eaf0;
            --text-dim: #6b7394;
            --success: #00e878;
            --danger: #ff4466;
            --radius: 14px;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        /* â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
        }

        /* â”€â”€ Top Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 50px 16px 12px;
            background: linear-gradient(to bottom, rgba(10, 14, 26, 0.95) 60%, transparent);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ble-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger);
            flex-shrink: 0;
            transition: background 0.3s;
            box-shadow: 0 0 8px var(--danger);
        }

        .ble-indicator.connected {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .top-bar .status-text {
            font-size: 13px;
            color: var(--text-dim);
            flex: 1;
        }

        /* â”€â”€ Bottom Sheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card);
            border-top: 1px solid var(--card-border);
            border-radius: 20px 20px 0 0;
            padding: 16px 16px calc(12px + var(--safe-bottom));
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .sheet-handle {
            width: 36px;
            height: 4px;
            background: var(--card-border);
            border-radius: 2px;
            margin: 0 auto 14px;
        }

        /* â”€â”€ Nav Info (shown during navigation) â”€â”€ */
        .nav-info {
            display: none;
            text-align: center;
            margin-bottom: 14px;
        }

        .nav-info.active {
            display: block;
        }

        .nav-icon {
            font-size: 42px;
            margin-bottom: 4px;
        }

        .nav-street {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nav-distance {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent);
        }

        .nav-unit {
            font-size: 14px;
            color: var(--text-dim);
            margin-left: 4px;
        }

        /* â”€â”€ Destination input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .dest-section {
            margin-bottom: 12px;
        }

        .dest-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }

        .dest-input:focus {
            border-color: var(--accent);
        }

        .dest-input::placeholder {
            color: var(--text-dim);
        }

        .dest-suggestions {
            display: none;
            margin-top: 8px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            max-height: 180px;
            overflow-y: auto;
        }

        .dest-suggestions.open {
            display: block;
        }

        .suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--card-border);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background: var(--accent-dim);
        }

        .suggestion-title {
            font-size: 14px;
            font-weight: 600;
        }

        .suggestion-sub {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: var(--radius);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-bottom: 8px;
        }

        .btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            transform: none;
        }

        .btn-connect {
            background: linear-gradient(135deg, #0066ff, #0099ff);
            color: white;
        }

        .btn-navigate {
            background: linear-gradient(135deg, #00b856, #00e878);
            color: white;
        }

        .btn-stop {
            background: var(--danger);
            color: white;
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn-row .btn {
            flex: 1;
        }

        /* â”€â”€ Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .log-toggle {
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
            padding: 6px;
            cursor: pointer;
        }

        .log-panel {
            display: none;
            max-height: 150px;
            overflow-y: auto;
            background: var(--bg);
            border-radius: 10px;
            padding: 10px;
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .log-panel.open {
            display: block;
        }

        .log-entry {
            padding: 3px 0;
            color: var(--text-dim);
        }

        .log-entry.sent {
            color: #3498db;
        }

        .log-entry.recv {
            color: var(--success);
        }

        .log-entry.err {
            color: var(--danger);
        }

        /* â”€â”€ Token Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .token-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.97);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .token-overlay.hidden {
            display: none;
        }

        .token-card {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 400px;
            width: 100%;
        }

        .token-card h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }

        .token-card p {
            font-size: 13px;
            color: var(--text-dim);
            margin-bottom: 16px;
        }

        .token-card input {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            color: var(--text);
            font-size: 14px;
            font-family: 'SF Mono', monospace;
            outline: none;
            margin-bottom: 12px;
        }

        .token-card input:focus {
            border-color: var(--accent);
        }

        .leaflet-control-attribution {
            background: rgba(10, 14, 26, 0.65);
            color: var(--text-dim);
            font-size: 10px;
        }

        .leaflet-control-attribution a {
            color: var(--text-dim);
        }

    </style>
</head>

<body>

    <!-- â•â•â•â• TOKEN OVERLAY â•â•â•â• -->
    <div class="token-overlay" id="keyOverlay">
        <div class="token-card">
            <h2>ğŸ—ºï¸ TomTom API Key</h2>
            <p>Paste your TomTom API key. It will be saved in your browser for next time.</p>
            <input type="text" id="keyInput" placeholder="TomTomKey..." autocomplete="off" spellcheck="false">
            <button class="btn btn-connect" id="keyBtn">Start Map</button>
        </div>
    </div>

    <!-- â•â•â•â• MAP â•â•â•â• -->
    <div id="map"></div>

    <!-- â•â•â•â• TOP BAR â•â•â•â• -->
    <div class="top-bar">
        <div class="ble-indicator" id="bleIndicator"></div>
        <span class="status-text" id="statusText">Tap Connect to pair with MotoHUD</span>
    </div>

    <!-- â•â•â•â• BOTTOM SHEET â•â•â•â• -->
    <div class="bottom-sheet">
        <div class="sheet-handle"></div>

        <!-- Nav info (visible during navigation) -->
        <div class="nav-info" id="navInfo">
            <div class="nav-icon" id="navIcon">â†‘</div>
            <div class="nav-street" id="navStreet">â€”</div>
            <div>
                <span class="nav-distance" id="navDist">--</span>
                <span class="nav-unit" id="navUnit"></span>
            </div>
        </div>

        <!-- Destination search -->
        <div class="dest-section" id="destSection">
            <input class="dest-input" id="destInput" type="text" placeholder="Where to?" autocomplete="off">
            <div class="dest-suggestions" id="destSuggestions"></div>
        </div>

        <!-- Buttons -->
        <div id="connectRow">
            <button class="btn btn-connect" id="connectBtn">ğŸ”µ Connect to MotoHUD</button>
        </div>
        <div id="navRow" style="display:none;">
            <div class="btn-row">
                <button class="btn btn-navigate" id="navBtn" disabled>Navigate</button>
                <button class="btn btn-stop" id="stopBtn" style="display:none;">Stop</button>
            </div>
        </div>

        <!-- Log -->
        <div class="log-toggle" id="logToggle">â–¼ Show Log</div>
        <div class="log-panel" id="logPanel"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let TOMTOM_KEY = localStorage.getItem('tomtom_key') || '';

        // BLE UUIDs â€” must match ESP32 firmware
        const BLE_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
        const BLE_NAV_CHAR_UUID = '12345678-1234-1234-1234-123456789abd';
        const BLE_DEVICE_NAME = 'MotoHUD';

        // Nav update rate (ms)
        const NAV_UPDATE_INTERVAL = 250;

        // Maneuver icon map â†’ icon_id for ESP32
        const MANEUVER_MAP = {
            'DEPART': 0,
            'STRAIGHT': 0,
            'KEEP_LEFT': 1,
            'BEAR_LEFT': 1,
            'TURN_LEFT': 1,
            'SHARP_LEFT': 1,
            'EXIT_LEFT': 1,
            'ROUNDABOUT_LEFT': 1,
            'KEEP_RIGHT': 2,
            'BEAR_RIGHT': 2,
            'TURN_RIGHT': 2,
            'SHARP_RIGHT': 2,
            'EXIT_RIGHT': 2,
            'ROUNDABOUT_RIGHT': 2,
            'MAKE_UTURN': 3,
            'UTURN_LEFT': 3,
            'UTURN_RIGHT': 3,
            'ARRIVE': 4,
            'ARRIVE_LEFT': 4,
            'ARRIVE_RIGHT': 4,
            'ENTER_MOTORWAY': 0,
            'EXIT_MOTORWAY': 0,
            'TAKE_EXIT': 0,
            'MERGE': 0,
            'ROUNDABOUT_CROSS': 0,
            'FERRY': 0,
            'RAIL_FERRY': 0,
            'PARKING': 0
        };

        const ICON_ARROWS = ['â†‘', 'â†', 'â†’', 'â†©', 'âœ“'];
        const PREVIEW_MAX_POINTS = 16;
        const PREVIEW_LOOKAHEAD = 400; // meters
        const PREVIEW_RANGE = 120; // coordinate range (-120..120)
        const PACKET_TYPE_NAV = 0;
        const PACKET_TYPE_MAP = 1;
        const NAV_CURRENT_BYTES = 28;
        const NAV_NEXT_BYTES = 28;
        const MAP_SEG_MAX = 8;
        const MAP_PTS_MAX = 12;
        const MAP_ZOOM = 16;
        const MAP_RADIUS_M = 240;
        const MAP_UPDATE_DIST_M = 10;
        const MAP_UPDATE_HEADING_DEG = 4;
        const MAP_UPDATE_MS = 1200;
        const OFF_ROUTE_METERS = 50;
        const OFF_ROUTE_HITS = 3;
        const REROUTE_COOLDOWN_MS = 20000;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let bleDevice = null, bleChar = null, bleConnected = false;
        let map, userMarker, accuracyCircle, gpsWatchId = null;
        let routePolyline = null;
        let destMarker = null;
        let hasCentered = false;
        let compassHeading = null;
        let lastCompassTs = 0;
        let gpsHeading = null;
        let lastPosForHeading = null;
        let lastNavPayload = null;
        let activeStepIdx = null;
        let offRouteCount = 0;
        let lastRerouteAt = 0;
        let isRerouting = false;
        let currentRoad = '';
        let lastRoadFetchAt = 0;
        let lastRoadPos = null;
        let roadAbort = null;
        let lastMapUpdateAt = 0;
        let lastMapPos = null;
        let lastMapHeading = null;
        let lastMapSendAt = 0;
        let tileCache = new Map();
        let currentPos = null;
        let routeGeometry = null, routeSteps = null;
        let navigating = false, navTimer = null;
        let destCoords = null;
        let lastSendTime = 0;
        let isWriting = false;
        let suggestionResults = [];
        let suggestTimer = null;
        let suggestAbort = null;

        // Background audio keep-alive
        let silentAudio = new Audio();
        silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAASAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAATMOpAAAAAABhAAaAAAAABzsDPwMHAwADAwMAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAA';
        silentAudio.loop = true;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  DOM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const $ = id => document.getElementById(id);
        const bleIndicator = $('bleIndicator');
        const statusText = $('statusText');
        const connectBtn = $('connectBtn');
        const navBtn = $('navBtn');
        const stopBtn = $('stopBtn');
        const navInfo = $('navInfo');
        const navIcon = $('navIcon');
        const navStreet = $('navStreet');
        const navDist = $('navDist');
        const navUnit = $('navUnit');
        const destInput = $('destInput');
        const destSuggestions = $('destSuggestions');
        const logPanel = $('logPanel');
        const logToggle = $('logToggle');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  LOG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function log(msg, type = '') {
            const ts = new Date().toLocaleTimeString('en-US', { hour12: false });
            const el = document.createElement('div');
            el.className = 'log-entry ' + type;
            el.textContent = `[${ts}] ${msg}`;
            logPanel.appendChild(el);
            logPanel.scrollTop = logPanel.scrollHeight;
            // keep max 100 entries
            while (logPanel.children.length > 100) logPanel.removeChild(logPanel.firstChild);
        }

        logToggle.onclick = () => {
            logPanel.classList.toggle('open');
            logToggle.textContent = logPanel.classList.contains('open') ? 'â–² Hide Log' : 'â–¼ Show Log';
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE  â€” Web Bluetooth
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function bleConnect() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth not available.\nUse Bluefy on iOS or Chrome on Android with HTTPS.');
                return;
            }

            try {
                // Start background audio (needs user gesture)
                silentAudio.play().then(() => {
                    log('ğŸµ Background audio started');
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: 'MotoHUD Active', artist: 'Navigation', album: 'Background Mode',
                        });
                        navigator.mediaSession.setActionHandler('play', () => silentAudio.play());
                        navigator.mediaSession.setActionHandler('pause', () => silentAudio.play());
                    }
                }).catch(e => log('Audio: ' + e.message, 'err'));

                silentAudio.onpause = () => {
                    silentAudio.play().catch(() => { });
                };

                statusText.textContent = 'Scanning for MotoHUDâ€¦';
                log('Requesting BLE deviceâ€¦');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: BLE_DEVICE_NAME }],
                    optionalServices: [BLE_SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onBleDisconnect);

                // Bluefy helpers
                if (navigator.bluetooth.setScreenDimEnabled) {
                    try { navigator.bluetooth.setScreenDimEnabled(false); } catch (_) { }
                }

                statusText.textContent = 'Connectingâ€¦';
                const server = await bleDevice.gatt.connect();
                const service = await server.getPrimaryService(BLE_SERVICE_UUID);
                bleChar = await service.getCharacteristic(BLE_NAV_CHAR_UUID);

                bleConnected = true;
                bleIndicator.classList.add('connected');
                statusText.textContent = 'Connected to MotoHUD';
                connectBtn.textContent = 'ğŸ”µ Connected';
                connectBtn.disabled = true;
                $('navRow').style.display = 'block';

                log('âœ… BLE connected');

            } catch (e) {
                log('BLE error: ' + (e.message || e), 'err');
                statusText.textContent = 'Connection failed â€” tap to retry';
                silentAudio.pause();
            }
        }

        function onBleDisconnect() {
            bleConnected = false;
            bleChar = null;
            bleIndicator.classList.remove('connected');
            statusText.textContent = 'Disconnected â€” tap Connect';
            connectBtn.textContent = 'ğŸ”µ Connect to MotoHUD';
            connectBtn.disabled = false;
            log('âŒ BLE disconnected');
            if (navigating) stopNavigation();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BLE â€” Typed packets
        //  NavPacketV2 (type = 0):
        //    uint8  packet_type
        //    uint8  icon_id
        //    uint32 dist_meters (LE)
        //    char   current_road[28]
        //    char   next_road[28]
        //    uint8  preview_count
        //    int8   preview_xy[32] (16 points: x,y)
        //    uint16 heading_deg (0-359, LE)
        //  Total: 97 bytes
        //
        //  MapPacket (type = 1):
        //    uint8  packet_type
        //    uint8  segment_count
        //    uint8  segment_counts[8]
        //    int8   segment_xy[192] (8 segments x 12 points x 2)
        //  Total: 202 bytes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Strip Vietnamese diacritics â†’ ASCII (ESP32 fonts are Latin-only)
        function stripDiacritics(str) {
            // Vietnamese-specific replacements for Ä‘/Ä (not handled by NFD)
            str = str.replace(/Ä‘/g, 'd').replace(/Ä/g, 'D');
            // NFD decompose then strip combining marks
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        // Truncate a string so its UTF-8 encoding fits within maxBytes
        function truncateToBytes(str, maxBytes) {
            const encoder = new TextEncoder();
            let encoded = encoder.encode(str);
            if (encoded.length <= maxBytes) return encoded;
            // Binary search for longest substring that fits
            let lo = 0, hi = str.length;
            while (lo < hi) {
                const mid = (lo + hi + 1) >> 1;
                if (encoder.encode(str.substring(0, mid)).length <= maxBytes) {
                    lo = mid;
                } else {
                    hi = mid - 1;
                }
            }
            return encoder.encode(str.substring(0, lo));
        }

        function stripHtml(html) {
            return (html || '').replace(/<[^>]+>/g, '').trim();
        }

        const PREVIEW_BYTES = PREVIEW_MAX_POINTS * 2;
        const NAV_TYPE_OFFSET = 0;
        const NAV_ICON_OFFSET = 1;
        const NAV_DIST_OFFSET = 2;
        const NAV_CURRENT_OFFSET = NAV_DIST_OFFSET + 4;
        const NAV_NEXT_OFFSET = NAV_CURRENT_OFFSET + NAV_CURRENT_BYTES;
        const NAV_PREVIEW_COUNT_OFFSET = NAV_NEXT_OFFSET + NAV_NEXT_BYTES;
        const NAV_PREVIEW_DATA_OFFSET = NAV_PREVIEW_COUNT_OFFSET + 1;
        const NAV_HEADING_OFFSET = NAV_PREVIEW_DATA_OFFSET + PREVIEW_BYTES;
        const NAV_PACKET_SIZE = NAV_HEADING_OFFSET + 2;

        const MAP_TYPE_OFFSET = 0;
        const MAP_COUNT_OFFSET = 1;
        const MAP_COUNTS_OFFSET = 2;
        const MAP_POINTS_OFFSET = MAP_COUNTS_OFFSET + MAP_SEG_MAX;
        const MAP_PACKET_SIZE = MAP_POINTS_OFFSET + (MAP_SEG_MAX * MAP_PTS_MAX * 2);

        async function sendNavPacket(iconId, distMeters, currentRoad, nextRoad, preview, headingDeg) {
            if (!bleChar || !bleConnected || isWriting) return;

            const now = Date.now();
            if (now - lastSendTime < NAV_UPDATE_INTERVAL) return;
            lastSendTime = now;

            isWriting = true;
            try {
                const buf = new ArrayBuffer(NAV_PACKET_SIZE);
                const dv = new DataView(buf);
                dv.setUint8(NAV_TYPE_OFFSET, PACKET_TYPE_NAV);
                dv.setUint8(NAV_ICON_OFFSET, iconId);
                dv.setUint32(NAV_DIST_OFFSET, Math.round(distMeters), true); // little-endian

                // Strip diacritics, truncate to fit bytes
                const currentAscii = stripDiacritics(currentRoad || '');
                const currentBytes = truncateToBytes(currentAscii, NAV_CURRENT_BYTES);
                const nextAscii = stripDiacritics(nextRoad || '');
                const nextBytes = truncateToBytes(nextAscii, NAV_NEXT_BYTES);
                const u8 = new Uint8Array(buf);
                u8.set(currentBytes, NAV_CURRENT_OFFSET);
                u8.set(nextBytes, NAV_NEXT_OFFSET);

                const previewCount = Math.min(PREVIEW_MAX_POINTS, preview?.count || 0);
                dv.setUint8(NAV_PREVIEW_COUNT_OFFSET, previewCount);
                const previewOffset = NAV_PREVIEW_DATA_OFFSET;
                for (let i = 0; i < PREVIEW_MAX_POINTS; i++) {
                    const idx = i * 2;
                    const px = preview?.points?.[i]?.x ?? 0;
                    const py = preview?.points?.[i]?.y ?? 0;
                    dv.setInt8(previewOffset + idx, px);
                    dv.setInt8(previewOffset + idx + 1, py);
                }

                const heading = Math.max(0, Math.min(359, Math.round(headingDeg || 0)));
                dv.setUint16(NAV_HEADING_OFFSET, heading, true);

                await bleChar.writeValueWithoutResponse(buf);
            } catch (e) {
                log('Send error: ' + e.message, 'err');
            } finally {
                isWriting = false;
            }
        }

        async function sendMapPacket(segments) {
            if (!bleChar || !bleConnected || isWriting) return;
            const now = Date.now();
            if (now - lastMapSendAt < 500) return;
            lastMapSendAt = now;

            isWriting = true;
            try {
                const buf = new ArrayBuffer(MAP_PACKET_SIZE);
                const dv = new DataView(buf);
                dv.setUint8(MAP_TYPE_OFFSET, PACKET_TYPE_MAP);

                const segCount = Math.min(MAP_SEG_MAX, segments.length);
                dv.setUint8(MAP_COUNT_OFFSET, segCount);

                const u8 = new Uint8Array(buf);
                for (let i = 0; i < MAP_SEG_MAX; i++) {
                    const seg = segments[i];
                    const count = seg ? Math.min(MAP_PTS_MAX, seg.length) : 0;
                    dv.setUint8(MAP_COUNTS_OFFSET + i, count);
                    const base = MAP_POINTS_OFFSET + (i * MAP_PTS_MAX * 2);
                    for (let p = 0; p < MAP_PTS_MAX; p++) {
                        const pt = seg && p < count ? seg[p] : { x: 0, y: 0 };
                        const px = Math.max(-128, Math.min(127, Math.round(pt.x ?? 0)));
                        const py = Math.max(-128, Math.min(127, Math.round(pt.y ?? 0)));
                        u8[base + (p * 2)] = px & 0xff;
                        u8[base + (p * 2) + 1] = py & 0xff;
                    }
                }

                await bleChar.writeValueWithoutResponse(buf);
            } catch (e) {
                log('Map send error: ' + e.message, 'err');
            } finally {
                isWriting = false;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  MAP â€” TomTom + Leaflet
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initMap() {
            if (map) {
                map.remove();
                map = null;
            }
            map = L.map('map', {
                zoomControl: false,
                attributionControl: true
            });

            userMarker = null;
            accuracyCircle = null;
            routePolyline = null;
            destMarker = null;
            hasCentered = false;

            const tileUrl = `https://{s}.api.tomtom.com/map/1/tile/basic/night/{z}/{x}/{y}.png?key=${encodeURIComponent(TOMTOM_KEY)}`;
            L.tileLayer(tileUrl, {
                maxZoom: 22,
                subdomains: 'abcd',
                tileSize: 256,
                attribution: 'Â© TomTom'
            }).addTo(map);

            map.setView([10.7769, 106.7009], 13);
            setupAutocomplete();
            startGpsWatch();
            log('ğŸ—ºï¸ Map initialized');
        }

        function setupAutocomplete() {
            destInput.addEventListener('input', () => {
                const q = destInput.value.trim();
                clearTimeout(suggestTimer);
                if (q.length < 2) {
                    renderSuggestions([]);
                    return;
                }
                suggestTimer = setTimeout(() => fetchSuggestions(q), 250);
            });

            destInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const q = destInput.value.trim();
                    if (!q) return;
                    if (suggestionResults.length > 0) {
                        selectSuggestion(suggestionResults[0]);
                    } else {
                        fetchSuggestions(q, true);
                    }
                }
            });

            destInput.addEventListener('blur', () => {
                setTimeout(() => renderSuggestions([]), 150);
            });

            destSuggestions.addEventListener('click', (e) => {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;
                const idx = Number(item.dataset.idx);
                const result = suggestionResults[idx];
                if (result) selectSuggestion(result);
            });
        }

        async function fetchSuggestions(query, pickFirst = false) {
            if (!TOMTOM_KEY || !query) return;

            if (suggestAbort) suggestAbort.abort();
            suggestAbort = new AbortController();

            try {
                const params = new URLSearchParams({
                    key: TOMTOM_KEY,
                    typeahead: 'true',
                    limit: '6',
                    countrySet: 'VN'
                });
                if (currentPos) {
                    params.set('lat', currentPos[1].toFixed(6));
                    params.set('lon', currentPos[0].toFixed(6));
                }

                const url = `https://api.tomtom.com/search/2/search/${encodeURIComponent(query)}.json?${params.toString()}`;
                const res = await fetch(url, { signal: suggestAbort.signal });
                const data = await res.json();
                const results = data.results || [];
                if (pickFirst && results.length > 0) {
                    selectSuggestion(results[0]);
                    return;
                }
                renderSuggestions(results);
            } catch (e) {
                if (e.name !== 'AbortError') {
                    log('Search error: ' + e.message, 'err');
                }
            }
        }

        function renderSuggestions(results) {
            suggestionResults = results || [];
            destSuggestions.innerHTML = '';
            if (!suggestionResults.length) {
                destSuggestions.classList.remove('open');
                return;
            }

            suggestionResults.forEach((r, idx) => {
                const title = r.poi?.name || r.address?.freeformAddress || 'Result';
                const sub = r.address?.freeformAddress || r.address?.municipality || r.address?.countrySubdivision || '';
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.dataset.idx = String(idx);

                const t = document.createElement('div');
                t.className = 'suggestion-title';
                t.textContent = title;
                item.appendChild(t);

                if (sub && sub !== title) {
                    const s = document.createElement('div');
                    s.className = 'suggestion-sub';
                    s.textContent = sub;
                    item.appendChild(s);
                }

                destSuggestions.appendChild(item);
            });

            destSuggestions.classList.add('open');
        }

        function selectSuggestion(result) {
            if (!result || !result.position) return;
            const { lat, lon } = result.position;
            destCoords = [lon, lat];
            const label = result.address?.freeformAddress || result.poi?.name || 'Destination';
            destInput.value = label;
            navBtn.disabled = false;
            renderSuggestions([]);
            log('ğŸ“ Destination: ' + label);

            if (destMarker) map.removeLayer(destMarker);
            destMarker = L.circleMarker([lat, lon], {
                radius: 6,
                color: '#ffffff',
                weight: 2,
                fillColor: '#ff4466',
                fillOpacity: 1
            }).addTo(map);

            if (currentPos) {
                fetchAndDrawRoute(currentPos, destCoords, true);
                fitBoundsToRoute(currentPos, destCoords);
            } else {
                map.setView([lat, lon], 14);
            }
        }

        function fitBoundsToRoute(origin, dest) {
            const bounds = L.latLngBounds(
                [origin[1], origin[0]],
                [dest[1], dest[0]]
            );
            map.fitBounds(bounds, { padding: [40, 160] });
        }

        // Fetch route and draw it. If `previewOnly`, just draw without starting nav.
        async function fetchAndDrawRoute(origin, dest, previewOnly = false) {
            try {
                if (!TOMTOM_KEY) {
                    log('Missing TomTom API key', 'err');
                    return null;
                }
                const params = new URLSearchParams({
                    key: TOMTOM_KEY,
                    travelMode: 'car',
                    instructionsType: 'coded',
                    language: 'en-US',
                    routeRepresentation: 'polyline',
                    computeTravelTimeFor: 'all',
                    traffic: 'true'
                });
                const url = `https://api.tomtom.com/routing/1/calculateRoute/${origin[1]},${origin[0]}:${dest[1]},${dest[0]}/json?${params.toString()}`;

                const res = await fetch(url);
                const data = await res.json();
                if (!data.routes || !data.routes.length) {
                    log('No route found', 'err');
                    return null;
                }

                const route = data.routes[0];
                const leg = route.legs?.[0];
                const points = leg?.points || [];
                const geometry = points.map(p => [p.longitude, p.latitude]);
                drawRoute(geometry);

                if (previewOnly) {
                    const meters = route.summary?.lengthInMeters || 0;
                    const mins = Math.max(1, Math.round((route.summary?.travelTimeInSeconds || 0) / 60));
                    const km = (meters / 1000).toFixed(1);
                    navBtn.textContent = `Navigate (${km} km Â· ${mins} min)`;
                    log(`Route preview: ${km} km, ~${mins} min`);
                }

                return { route, geometry };
            } catch (e) {
                log('Route error: ' + e.message, 'err');
                return null;
            }
        }

        function buildRouteSteps(route, routeLine) {
            const steps = [];
            const instructions = route.guidance?.instructions || [];
            for (const instr of instructions) {
                if (!instr.point) continue;
                const name = instr.street || instr.signpostText || instr.roadNumbers?.[0] || instr.message || '';
                const location = [instr.point.longitude, instr.point.latitude];
                const snapped = turf.nearestPointOnLine(routeLine, turf.point(location), { units: 'meters' });
                const routeDist = snapped?.properties?.location ?? 0;
                steps.push({
                    maneuver: instr.maneuver || 'STRAIGHT',
                    name: stripHtml(name),
                    location,
                    turnAngle: instr.turnAngleInDecimalDegrees || 0,
                    routeDist
                });
            }

            if (steps.length === 0 && routeLine?.geometry?.coordinates?.length) {
                const last = routeLine.geometry.coordinates[routeLine.geometry.coordinates.length - 1];
                steps.push({
                    maneuver: 'ARRIVE',
                    name: 'Destination',
                    location: last,
                    turnAngle: 0,
                    routeDist: turf.length(routeLine, { units: 'meters' })
                });
            }
            return steps;
        }

        function applyRouteResult(result) {
            if (!result) return false;
            const route = result.route;
            routeGeometry = {
                type: 'LineString',
                coordinates: result.geometry
            };
            const routeLine = turf.lineString(routeGeometry.coordinates);
            routeSteps = buildRouteSteps(route, routeLine);
            activeStepIdx = null;
            offRouteCount = 0;
            return true;
        }

        async function triggerReroute() {
            if (isRerouting || !currentPos || !destCoords) return;
            const now = Date.now();
            if (now - lastRerouteAt < REROUTE_COOLDOWN_MS) return;
            isRerouting = true;
            lastRerouteAt = now;
            statusText.textContent = 'Reroutingâ€¦';
            log('ğŸ” Reroutingâ€¦');

            const result = await fetchAndDrawRoute(currentPos, destCoords, false);
            if (applyRouteResult(result)) {
                log('âœ… Reroute complete');
            } else {
                log('âš ï¸ Reroute failed', 'err');
            }
            statusText.textContent = 'Navigatingâ€¦';
            isRerouting = false;
        }

        function drawRoute(coords) {
            if (routePolyline) map.removeLayer(routePolyline);
            const latLngs = coords.map(c => [c[1], c[0]]);
            routePolyline = L.polyline(latLngs, {
                color: '#00c8ff',
                weight: 5,
                opacity: 0.85
            }).addTo(map);

        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  GPS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function updateUserMarker(pos) {
            if (!map) return;
            const latLng = [pos.coords.latitude, pos.coords.longitude];

            if (!userMarker) {
                userMarker = L.circleMarker(latLng, {
                    radius: 6,
                    color: '#ffffff',
                    weight: 2,
                    fillColor: '#00c8ff',
                    fillOpacity: 1
                }).addTo(map);
            } else {
                userMarker.setLatLng(latLng);
            }

            if (!accuracyCircle) {
                accuracyCircle = L.circle(latLng, {
                    radius: pos.coords.accuracy || 10,
                    color: '#00c8ff',
                    weight: 1,
                    opacity: 0.35,
                    fillColor: '#00c8ff',
                    fillOpacity: 0.12
                }).addTo(map);
            } else {
                accuracyCircle.setLatLng(latLng);
                accuracyCircle.setRadius(pos.coords.accuracy || 10);
            }

            if (!hasCentered) {
                map.setView(latLng, 15);
                hasCentered = true;
            }

            updateGpsHeading(pos);
        }

        function startGpsWatch() {
            if (!navigator.geolocation) { log('No GPS', 'err'); return; }
            gpsWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    updateUserMarker(pos);
                    if (destCoords && !routePolyline) {
                        fetchAndDrawRoute(currentPos, destCoords, true);
                    }
                    if (navigating) onGpsUpdate();
                },
                (err) => log('GPS error: ' + err.message, 'err'),
                { enableHighAccuracy: true, maximumAge: 2000 }
            );
            log('ğŸ“¡ GPS watch started');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  NAVIGATION ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function startNavigation() {
            if (!currentPos) {
                // Actively request GPS (triggers permission prompt if needed)
                statusText.textContent = 'Requesting GPSâ€¦';
                log('ğŸ“¡ Requesting GPS permissionâ€¦');
                try {
                    const pos = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true, timeout: 10000
                        });
                    });
                    currentPos = [pos.coords.longitude, pos.coords.latitude];
                    startGpsWatch(); // restart watch now that we have permission
                } catch (e) {
                    alert('Cannot get GPS location. Please allow location access and try again.');
                    statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                    log('GPS denied: ' + e.message, 'err');
                    return;
                }
            }
            if (!destCoords) {
                alert('Please select a destination first');
                return;
            }

            log('ğŸ§­ Starting navigationâ€¦');
            statusText.textContent = 'Calculating routeâ€¦';

            const result = await fetchAndDrawRoute(currentPos, destCoords, false);
            if (!applyRouteResult(result)) {
                alert('No route found');
                statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';
                return;
            }

            const totalDist = result.route.summary?.lengthInMeters || 0;
            log(`Route: ${routeSteps.length} steps, ${(totalDist / 1000).toFixed(1)} km`);

            // Start nav mode
            navigating = true;
            lastMapUpdateAt = 0;
            lastMapPos = null;
            lastMapHeading = null;
            navInfo.classList.add('active');
            navBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            $('destSection').style.display = 'none';
            statusText.textContent = 'Navigatingâ€¦';

            // Initial update
            onGpsUpdate();
        }

        function stopNavigation() {
            navigating = false;
            navInfo.classList.remove('active');
            navBtn.style.display = 'block';
            navBtn.textContent = 'Navigate';
            stopBtn.style.display = 'none';
            $('destSection').style.display = 'block';
            statusText.textContent = bleConnected ? 'Connected to MotoHUD' : 'Disconnected';

            // Remove route preview
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            routeGeometry = null;
            routeSteps = null;
            lastNavPayload = null;
            activeStepIdx = null;
            offRouteCount = 0;
            isRerouting = false;
            lastMapUpdateAt = 0;
            lastMapPos = null;
            lastMapHeading = null;

            log('â¹ Navigation stopped');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  SNAPPING ENGINE (Turf.js)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function maneuverToIconId(step) {
            const key = (step?.maneuver || '').toUpperCase();
            if (MANEUVER_MAP[key] !== undefined) return MANEUVER_MAP[key];
            const angle = step?.turnAngle || 0;
            if (angle > 15) return 2;
            if (angle < -15) return 1;
            return 0;
        }

        function normalizeHeading(deg) {
            return ((deg % 360) + 360) % 360;
        }

        function shortestAngleDelta(from, to) {
            return ((to - from + 540) % 360) - 180;
        }

        function setCompassHeading(deg) {
            const normalized = normalizeHeading(deg);
            if (compassHeading === null) {
                compassHeading = normalized;
            } else {
                const delta = shortestAngleDelta(compassHeading, normalized);
                compassHeading = normalizeHeading(compassHeading + delta * 0.25);
            }
            lastCompassTs = Date.now();
        }

        function updateGpsHeading(pos) {
            if (!pos || !pos.coords) return;
            if (Number.isFinite(pos.coords.heading)) {
                gpsHeading = normalizeHeading(pos.coords.heading);
                lastPosForHeading = [pos.coords.longitude, pos.coords.latitude];
                return;
            }

            const lon = pos.coords.longitude;
            const lat = pos.coords.latitude;
            if (!Number.isFinite(lon) || !Number.isFinite(lat)) return;

            if (!lastPosForHeading) {
                lastPosForHeading = [lon, lat];
                return;
            }

            const from = turf.point(lastPosForHeading);
            const to = turf.point([lon, lat]);
            const dist = turf.distance(from, to, { units: 'meters' });
            if (dist < 4) return;

            const bearing = turf.bearing(from, to);
            gpsHeading = normalizeHeading(bearing);
            lastPosForHeading = [lon, lat];
        }

        function getHeadingToSend() {
            const now = Date.now();
            if (compassHeading !== null && now - lastCompassTs < 5000) {
                return compassHeading;
            }
            if (gpsHeading !== null) return gpsHeading;
            return 0;
        }

        function handleOrientation(event) {
            let heading = null;
            if (typeof event.webkitCompassHeading === 'number') {
                heading = event.webkitCompassHeading;
            } else if (typeof event.alpha === 'number') {
                const screenAngle = (screen.orientation && typeof screen.orientation.angle === 'number')
                    ? screen.orientation.angle
                    : (typeof window.orientation === 'number' ? window.orientation : 0);
                heading = 360 - event.alpha + screenAngle;
            }
            if (heading !== null && !Number.isNaN(heading)) {
                setCompassHeading(heading);
                if (navigating && lastNavPayload) {
                    let preview = lastNavPayload.preview;
                    if (routeGeometry && Number.isFinite(lastNavPayload.snapDist)) {
                        const routeLine = turf.lineString(routeGeometry.coordinates);
                        preview = buildPreviewPoints(
                            routeLine,
                            lastNavPayload.snapDist,
                            lastNavPayload.distToTurn,
                            getHeadingToSend()
                        );
                        lastNavPayload.preview = preview;
                    }
                    sendNavPacket(
                        lastNavPayload.iconId,
                        lastNavPayload.distMeters,
                        lastNavPayload.currentRoad,
                        lastNavPayload.nextRoad,
                        preview,
                        getHeadingToSend()
                    );
                    maybeUpdateMapBackground(getHeadingToSend());
                }
            }
        }

        async function requestOrientationPermission() {
            if (typeof DeviceOrientationEvent === 'undefined') return;
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const res = await DeviceOrientationEvent.requestPermission();
                    if (res === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        window.addEventListener('deviceorientationabsolute', handleOrientation, true);
                    }
                } catch (e) {
                    log('Compass permission denied', 'err');
                }
            } else {
                window.addEventListener('deviceorientationabsolute', handleOrientation, true);
                window.addEventListener('deviceorientation', handleOrientation, true);
            }
        }

        function distanceMeters(a, b) {
            if (!a || !b) return Infinity;
            return turf.distance(turf.point(a), turf.point(b), { units: 'meters' });
        }

        async function maybeUpdateCurrentRoad() {
            if (!TOMTOM_KEY || !currentPos) return;
            const now = Date.now();
            const moved = distanceMeters(lastRoadPos, currentPos);
            if (moved < 50 && now - lastRoadFetchAt < 10000) return;

            lastRoadFetchAt = now;
            lastRoadPos = [...currentPos];

            if (roadAbort) roadAbort.abort();
            roadAbort = new AbortController();

            try {
                const url = `https://api.tomtom.com/search/2/reverseGeocode/${currentPos[1]},${currentPos[0]}.json?key=${encodeURIComponent(TOMTOM_KEY)}`;
                const res = await fetch(url, { signal: roadAbort.signal });
                if (!res.ok) return;
                const data = await res.json();
                const addr = data.addresses?.[0]?.address || {};
                const road = addr.streetName || addr.street || addr.freeformAddress || '';
                currentRoad = stripHtml(road);
                if (lastNavPayload) lastNavPayload.currentRoad = currentRoad;
            } catch (e) {
                if (e.name !== 'AbortError') {
                    log('Reverse geocode error: ' + e.message, 'err');
                }
            }
        }

        function lonLatToTile(lon, lat, zoom) {
            const z2 = Math.pow(2, zoom);
            const x = Math.floor((lon + 180) / 360 * z2);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * z2);
            return { x, y };
        }

        function tileCoordToLonLat(tileX, tileY, zoom, x, y, extent) {
            const z2 = Math.pow(2, zoom);
            const lon = ((tileX + x / extent) / z2) * 360 - 180;
            const n = Math.PI - 2 * Math.PI * (tileY + y / extent) / z2;
            const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
            return [lon, lat];
        }

        let vectorTileLibPromise = null;

        function getVectorTileCtor() {
            if (window.VectorTile) return window.VectorTile;
            if (window.vectorTile && window.vectorTile.VectorTile) return window.vectorTile.VectorTile;
            if (window.vectorTile) return window.vectorTile;
            if (window.mapboxVectorTile && window.mapboxVectorTile.VectorTile) return window.mapboxVectorTile.VectorTile;
            if (window.mapboxVectorTile) return window.mapboxVectorTile;
            if (window.MapboxVectorTile && window.MapboxVectorTile.VectorTile) return window.MapboxVectorTile.VectorTile;
            return null;
        }

        function getPbfCtor() {
            return window.Pbf || window.pbf || null;
        }

        function loadScriptOnce(src, isReady) {
            return new Promise((resolve, reject) => {
                const existing = document.querySelector(`script[src="${src}"]`);
                if (existing) {
                    if (typeof isReady === 'function' && isReady()) {
                        resolve();
                        return;
                    }
                    if (existing.dataset.loaded === '1') {
                        resolve();
                        return;
                    }
                    let settled = false;
                    const onReadyCheck = () => {
                        if (!settled && typeof isReady === 'function' && isReady()) {
                            settled = true;
                            resolve();
                        }
                    };
                    const onLoad = () => {
                        existing.dataset.loaded = '1';
                        if (!settled) {
                            settled = true;
                            resolve();
                        }
                    };
                    const onError = () => {
                        if (!settled) {
                            settled = true;
                            reject(new Error(`Failed to load ${src}`));
                        }
                    };
                    existing.addEventListener('load', onLoad, { once: true });
                    existing.addEventListener('error', onError, { once: true });
                    setTimeout(onReadyCheck, 0);
                    return;
                }
                const s = document.createElement('script');
                s.src = src;
                s.async = true;
                s.onload = () => { s.dataset.loaded = '1'; resolve(); };
                s.onerror = () => reject(new Error(`Failed to load ${src}`));
                document.head.appendChild(s);
            });
        }

        async function ensureVectorTileLibs() {
            if (getPbfCtor() && getVectorTileCtor()) return true;
            if (vectorTileLibPromise) return vectorTileLibPromise;
            vectorTileLibPromise = (async () => {
                if (!getVectorTileCtor()) {
                    try {
                        const mod = await import('https://cdn.jsdelivr.net/npm/@mapbox/vector-tile@2.0.4/+esm');
                        const ctor = mod?.VectorTile || mod?.default?.VectorTile;
                        if (ctor) {
                            window.VectorTile = ctor;
                        }
                    } catch (_) { }
                }

                const pbfSources = [
                    'https://cdn.jsdelivr.net/npm/pbf@3.2.1/dist/pbf.min.js',
                    'https://cdn.jsdelivr.net/npm/pbf@3.2.1/dist/pbf.js',
                    'https://unpkg.com/pbf@3.2.1/dist/pbf.min.js',
                    'https://unpkg.com/pbf@3.2.1/dist/pbf.js'
                ];
                const vtSources = [
                    'https://cdn.jsdelivr.net/npm/@mapbox/vector-tile@1.3.1/dist/vector-tile.min.js',
                    'https://cdn.jsdelivr.net/npm/@mapbox/vector-tile@1.3.1/dist/vector-tile.js',
                    'https://unpkg.com/@mapbox/vector-tile@1.3.1/dist/vector-tile.min.js',
                    'https://unpkg.com/@mapbox/vector-tile@1.3.1/dist/vector-tile.js'
                ];

                for (const src of pbfSources) {
                    try {
                        await loadScriptOnce(src, () => Boolean(getPbfCtor()));
                        if (getPbfCtor()) break;
                    } catch (_) { }
                }
                for (const src of vtSources) {
                    try {
                        await loadScriptOnce(src, () => Boolean(getVectorTileCtor()));
                        if (getVectorTileCtor()) break;
                    } catch (_) { }
                }
                return Boolean(getPbfCtor() && getVectorTileCtor());
            })();
            return vectorTileLibPromise;
        }

        function shouldUseLayer(name) {
            const n = (name || '').toLowerCase();
            return n.includes('road') || n.includes('street') || n.includes('transport') || n.includes('path');
        }

        async function getVectorTileLines(lon, lat) {
            if (!TOMTOM_KEY) return [];
            const tile = lonLatToTile(lon, lat, MAP_ZOOM);
            const key = `${MAP_ZOOM}/${tile.x}/${tile.y}`;
            if (tileCache.has(key)) {
                return tileCache.get(key);
            }

            const libsReady = await ensureVectorTileLibs();
            const VectorTile = getVectorTileCtor();
            const PbfCtor = getPbfCtor();
            if (!libsReady || !VectorTile || !PbfCtor) {
                log('Vector tile libs not loaded', 'err');
                return [];
            }

            try {
                const url = `https://api.tomtom.com/map/1/tile/basic/main/${MAP_ZOOM}/${tile.x}/${tile.y}.pbf?key=${encodeURIComponent(TOMTOM_KEY)}`;
                const res = await fetch(url);
                if (!res.ok) return [];
                const buf = await res.arrayBuffer();
                const vt = new VectorTile(new PbfCtor(new Uint8Array(buf)));
                const lines = [];
                const layers = vt.layers || {};
                for (const name of Object.keys(layers)) {
                    if (!shouldUseLayer(name)) continue;
                    const layer = layers[name];
                    const extent = layer.extent || 4096;
                    for (let i = 0; i < layer.length; i++) {
                        const feature = layer.feature(i);
                        if (feature.type !== 2) continue;
                        const geom = feature.loadGeometry();
                        for (const line of geom) {
                            if (line.length < 2) continue;
                            const linePts = line.map(pt => tileCoordToLonLat(tile.x, tile.y, MAP_ZOOM, pt.x, pt.y, extent));
                            lines.push(linePts);
                        }
                    }
                }
                if (tileCache.size > 6) tileCache.clear();
                tileCache.set(key, lines);
                return lines;
            } catch (e) {
                log('Vector tile error: ' + e.message, 'err');
                return [];
            }
        }

        function simplifySegment(points, maxPoints) {
            if (points.length <= maxPoints) return points;
            const out = [];
            const step = (points.length - 1) / (maxPoints - 1);
            for (let i = 0; i < maxPoints; i++) {
                const idx = Math.round(i * step);
                out.push(points[idx]);
            }
            return out;
        }

        function lineToSegment(line, originPt, headingDeg) {
            const headingRef = Number.isFinite(headingDeg) ? headingDeg : 0;
            const seg = [];
            for (const coord of line) {
                const pt = turf.point(coord);
                const dist = turf.distance(originPt, pt, { units: 'meters' });
                if (dist > MAP_RADIUS_M * 1.1) continue;
                const bearing = turf.bearing(originPt, pt);
                const rel = (bearing - headingRef) * Math.PI / 180;
                const x = Math.sin(rel) * dist;
                const y = Math.cos(rel) * dist;
                const scale = PREVIEW_RANGE / MAP_RADIUS_M;
                let sx = Math.round(x * scale);
                let sy = Math.round(y * scale);
                sx = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sx));
                sy = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sy));
                seg.push({ x: sx, y: sy });
            }
            if (seg.length < 2) return null;
            return simplifySegment(seg, MAP_PTS_MAX);
        }

        async function maybeUpdateMapBackground(headingDeg) {
            if (!navigating || !currentPos || isRerouting) return;
            const now = Date.now();
            const moved = distanceMeters(lastMapPos, currentPos);
            const headingDelta = lastMapHeading === null
                ? 360
                : Math.abs(shortestAngleDelta(lastMapHeading, headingDeg));

            if (moved < MAP_UPDATE_DIST_M &&
                headingDelta < MAP_UPDATE_HEADING_DEG &&
                now - lastMapUpdateAt < MAP_UPDATE_MS) {
                return;
            }

            lastMapUpdateAt = now;
            lastMapPos = [...currentPos];
            lastMapHeading = headingDeg;

            const lines = await getVectorTileLines(currentPos[0], currentPos[1]);
            const originPt = turf.point(currentPos);
            const segments = [];
            for (const line of lines) {
                if (segments.length >= MAP_SEG_MAX) break;
                const seg = lineToSegment(line, originPt, headingDeg);
                if (seg && seg.length >= 2) segments.push(seg);
            }
            if (segments.length) {
                sendMapPacket(segments);
            }
        }

        function buildPreviewPoints(routeLine, snapDist, distToTurn, headingDeg) {
            const lineLength = turf.length(routeLine, { units: 'meters' });
            if (!isFinite(lineLength) || lineLength <= 0) return { count: 0, points: [] };

            const basePoint = turf.along(routeLine, snapDist, { units: 'meters' });
            const aheadPoint = turf.along(routeLine, Math.min(snapDist + 10, lineLength), { units: 'meters' });
            const routeHeading = turf.bearing(basePoint, aheadPoint);
            const headingRef = Number.isFinite(headingDeg) ? headingDeg : routeHeading;
            const remaining = Math.max(0, lineLength - snapDist);
            let lookahead = Math.min(PREVIEW_LOOKAHEAD, remaining);
            if (Number.isFinite(distToTurn)) {
                const bonus = distToTurn < 120 ? 220 : 60;
                const target = distToTurn + bonus;
                lookahead = Math.min(PREVIEW_LOOKAHEAD, Math.max(120, Math.min(target, remaining)));
            }
            const step = PREVIEW_MAX_POINTS > 1 ? lookahead / (PREVIEW_MAX_POINTS - 1) : 0;
            const points = [];

            for (let i = 0; i < PREVIEW_MAX_POINTS; i++) {
                const d = Math.min(snapDist + step * i, lineLength);
                const p = turf.along(routeLine, d, { units: 'meters' });
                const dist = turf.distance(basePoint, p, { units: 'meters' });
                const bearing = turf.bearing(basePoint, p);
                const rel = (bearing - headingRef) * Math.PI / 180;
                const x = Math.sin(rel) * dist;
                const y = Math.cos(rel) * dist;
                const scale = PREVIEW_RANGE / PREVIEW_LOOKAHEAD;
                let sx = Math.round(x * scale);
                let sy = Math.round(y * scale);
                sx = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sx));
                sy = Math.max(-PREVIEW_RANGE, Math.min(PREVIEW_RANGE, sy));
                points.push({ x: sx, y: sy });
            }

            return { count: points.length, points };
        }

        function onGpsUpdate() {
            if (!currentPos || !routeGeometry || !routeSteps || routeSteps.length === 0) return;
            if (isRerouting) return;

            maybeUpdateCurrentRoad();

            const routeLine = turf.lineString(routeGeometry.coordinates);
            const pt = turf.point(currentPos);

            // Snap to route
            const snapped = turf.nearestPointOnLine(routeLine, pt, { units: 'meters' });
            const snappedDist = snapped.properties.location;
            const offDist = Number.isFinite(snapped.properties?.dist)
                ? snapped.properties.dist
                : turf.distance(pt, snapped, { units: 'meters' });

            if (offDist > OFF_ROUTE_METERS) {
                offRouteCount += 1;
            } else {
                offRouteCount = 0;
            }

            if (offRouteCount >= OFF_ROUTE_HITS) {
                offRouteCount = 0;
                triggerReroute();
                return;
            }

            if (activeStepIdx === null || activeStepIdx >= routeSteps.length) {
                activeStepIdx = routeSteps.findIndex(step => step.routeDist >= snappedDist - 5);
                if (activeStepIdx === -1) activeStepIdx = routeSteps.length - 1;
            }

            while (activeStepIdx < routeSteps.length - 1 &&
                snappedDist > (routeSteps[activeStepIdx].routeDist + 20)) {
                activeStepIdx += 1;
            }

            const nextStep = routeSteps[activeStepIdx];
            if (!nextStep) return;

            // Distance from current position to next maneuver
            const maneuverPt = turf.point(nextStep.location);
            const distToTurn = turf.distance(pt, maneuverPt, { units: 'meters' });

            // Map maneuver type â†’ icon_id
            let iconId = maneuverToIconId(nextStep);

            // Check for arrival
            const maneuverKey = (nextStep.maneuver || '').toUpperCase();
            if (maneuverKey.startsWith('ARRIVE') || (activeStepIdx === routeSteps.length - 1 && distToTurn < 50)) {
                iconId = 4;
            }

            const nextRoad = nextStep.name || '';
            const displayStreet = nextRoad || currentRoad || 'â€”';
            const headingToSend = getHeadingToSend();
            const preview = buildPreviewPoints(routeLine, snappedDist, distToTurn, headingToSend);
            lastNavPayload = {
                iconId,
                distMeters: distToTurn,
                currentRoad,
                nextRoad,
                preview,
                snapDist: snappedDist,
                distToTurn
            };

            // Update web UI
            navIcon.textContent = ICON_ARROWS[iconId] || 'â†‘';
            navStreet.textContent = displayStreet;
            if (distToTurn >= 1000) {
                navDist.textContent = (distToTurn / 1000).toFixed(1);
                navUnit.textContent = 'km';
            } else {
                navDist.textContent = Math.round(distToTurn);
                navUnit.textContent = 'm';
            }

            // Send to ESP32
            sendNavPacket(iconId, distToTurn, currentRoad, nextRoad, preview, headingToSend);
            maybeUpdateMapBackground(headingToSend);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  API KEY FLOW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const keyOverlay = $('keyOverlay');
        const keyInput = $('keyInput');
        const keyBtn = $('keyBtn');

        function applyKey() {
            const k = keyInput.value.trim();
            if (!k || k.length < 10) {
                alert('Please enter a valid TomTom API key');
                return;
            }
            TOMTOM_KEY = k;
            localStorage.setItem('tomtom_key', k);
            keyOverlay.classList.add('hidden');
            initMap();
            requestOrientationPermission();
        }

        keyBtn.addEventListener('click', applyKey);
        keyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyKey(); });

        // Auto-init if key already saved
        if (TOMTOM_KEY && TOMTOM_KEY.length > 10) {
            keyOverlay.classList.add('hidden');
            initMap();
        } else {
            keyInput.focus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  EVENT LISTENERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        connectBtn.addEventListener('click', bleConnect);
        connectBtn.addEventListener('click', requestOrientationPermission);
        navBtn.addEventListener('click', startNavigation);
        navBtn.addEventListener('click', requestOrientationPermission);
        stopBtn.addEventListener('click', stopNavigation);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('ğŸ“± App backgrounded');
            } else {
                log('ğŸ“± App foregrounded');
            }
        });

        window.addEventListener('load', () => {
            if (!navigator.bluetooth) {
                log('âš ï¸ Web Bluetooth not available â€” use Bluefy or Chrome HTTPS', 'err');
            } else {
                log('âœ… Web Bluetooth ready');
            }
        });
    </script>
</body>

</html>
